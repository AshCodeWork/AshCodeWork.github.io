{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/22/hello-world/"},{"title":"Typescript系列课程(一)","text":"本次主要讲的内容： 基础类型 布尔值 数字 字符串 数组 Any Void Null 和 Undefined Object 元祖Tuple 枚举 Never 类型断言 接口 一个例子 可选属性 只读属性 额外属性检查 函数类型 可索引的类型 类类型 继承接口 混合类型 接口继承类 快速上手：点我跳转 Typescript文档地址：点我跳转 练习地址：点我跳转 基础类型布尔值1let isDone: boolean = false; 数字1let decLiteral: number = 6; 字符串12let name: string = \"bob\";name = \"smith\"; 模板字符串 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is ${ name }.I'll be ${ age + 1 } years old next month.`; 输出： 123Hello, my name is Gene.I'll be 38 years old next month. 数组方式一：直接指定类型 12//例如：定义一个数字类型的数组let list: number[] = [1, 2, 3]; 方式二：使用泛型 12345//使用数组泛型，Array&lt;元素类型&gt;// 定义一个数字的let list: Array&lt;number&gt; = [1, 2, 3]; // 定义一个字符串的let list: Array&lt;string&gt; = ['a','b','c']; Any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量： 总结：就是你也不知道什么类型用any 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; //这样也是可以定义的，因为没有固定类型 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // ok，ifItExists 这个方法可能在执行时存在notSure.toFixed(); // ok, toFixed存在 (但是编译器不会检查)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 1234function warnUser(): void { console.log(\"这是一条警告消息\");}//这个方法没有返回值 Null 和 Undefined12345//我们不能再给这些变量赋值let u: undefined = undefined;let n: null = null;u=123 //报错 Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型 1234567891011// 声明一个create方法 参数为object或null 没有返回值declare function create(o: object | null): void;create({ prop: 0 }); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Errorcreate(); //Error 元祖Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];x = ['hello', 10]; // OKx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型, 因为之前的两个类型是number类型和string类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 12enum Color {Red, Green, Blue}let c: Color = Color.Green; //1 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： 12enum Color {Red = 1, Green, Blue}let c: Color = Color.Green; //2 或者，全部都采用手动赋值： 12enum Color {Red = 1, Green = 2, Blue = 4}let c: Color = Color.Green; Nevernever类型表示的是那些永不存在的值的类型。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never { throw new Error(message);}// 推断的返回值类型为neverfunction fail() { return error(\"Something failed\");}// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never { while (true) { }} 类型断言通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 有两种写法： 写法一：尖括号 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 写法二：as（推荐） 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。 接口在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 基本使用举个例子： 123456function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label);}let myObj = { size: 10, label: \"Size 10 Object\" };printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 这个时候我们就可以使用接口写法代替上面的写法 基本接口写法： 123interface 接口名 { 属性名: 类型;} 注意： 如果使用这个接口的话，不能传入额外的属性，如果需要传入额外的属性，参考后面的额外属性检查 通过接口写法我们可以把上面的例子改成下面这样： 1234567891011// 定义一个名为LabelledValue的接口interface LabelledValue { label: string;}// 定义printLabelfunction printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label);}let myObj = {size: 10, label: \"Size 10 Object\"};printLabel(myObj); //Size 10 Objec 可选属性可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 写法：在属性名后面增加一个？ 123interface 接口名 { 属性名?: 类型;} 123456789101112131415161718192021// 定一个一个可选属性接口interface SquareConfig { color?: string; width?: number;}// 创建一个正方形 传入颜色和宽度，返回颜色和面积function createSquare(config: SquareConfig): {color: string; area: number} { // 默认 白色 100 let newSquare = {color: \"white\", area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare;}let mySquare = createSquare({color: \"black\"}); //{ area: 100, color: 'black' }mySquare = createSquare({color: \"black\", width: 2});//{ area: 4, color: 'black' } 只读属性一些对象属性只能在对象刚刚创建的时候修改其值 写法：属性名前加readonly 123interface 接口名 { readonly 属性名: 类型;} 12345678interface Point { readonly x: number; readonly y: number;}// 定义一个p1变量，使用point接口let p1: Point = { x: 10, y: 20 };//修改x的值p1.x = 5; // error! 设置只读数组TypeScript具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： 1234567let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;console.log(ro[0]) // ok，可以读取ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 想要改成普通类型，只能使用类型断言重写 1a = ro as number[]; readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 额外属性检查先看一个例子： 123456789101112// 定义一个可选属性的接口interface SquareConfig { color?: string; width?: number;}function createSquare(config: SquareConfig): void { console.log(config.color) //undefined console.log(config.width) // 100}//这里我们假设打错了一个属性color -&gt; colourlet mySquare = createSquare({ colour: \"red\", width: 100 }); 这里程序会认为你设置的属性不对，ts会给colour有个红线，即便是可选属性。 我们有三个方案可以绕开这个检测： 方案一：使用断言 1let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 方案二：重新赋值 12let squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions); 方案三：使用额外属性写法 123456//如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它interface SquareConfig { color?: string; width?: number; [propName: string]: any;} 函数类型定义一个函数类型的接口 123interface 接口名 { (参数1: 类型, 参数2: 类型): 返回值类型} 举个例子 1234567891011// 定义一个接口，接受两个参数：字符串的source 和 字符串的subString 结果返回布尔类型interface SearchFunc { (source: string, subString: string): boolean;}// 设置接口类型let mySearch: SearchFunc;// 定义方法mySearch = function(source: string, subString: string) { let result = source.search(subString); return result &gt; -1;} 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 比如，我们使用下面的代码重写上面的例子： 12345678910interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc;// 这里参数名称变成src 和 sub了mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result &gt; -1;} 如果你不想指定类型，TypeScript的类型系统会推断出参数类型 12345678910interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(src, sub) { let result = src.search(sub); return result &gt; -1;}//因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[&quot;daniel&quot;]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 TypeScript支持两种索引签名：字符串和数字 数字索引签名 12345678interface StringArray { [index: number]: string; //数字索引签名}let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 字符串索引签名 12345678interface Animal { [name: string]: string //字符串索引签名}let dog: Animal = { name: 'dog', //只能设置值为string类型 age: 44 //error 不能设置值为数字} 类类型实现接口TypeScript也能够用它来明确的强制一个类去符合某种契约。 注：接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 123456789101112interface ClockInterface { currentTime: Date; setTime(d: Date); //描述一个方法站在类里实现它}class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { }} 类静态部分与实例部分的区别当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 123456789101112131415161718192021222324252627282930//用于构造函数的interface ClockConstructor { new (hour: number, minute: number): ClockInterface;}// 用于实例方法的interface ClockInterface { tick();}// 工厂函数function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute);}// 定义一个数字钟class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"beep beep\"); }}// 定义一个模拟时钟class AnalogClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"tick tock\"); }}// 调用工厂函数实例化let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1234567891011interface Shape { color: string;}// 继承Shape接口形成一个新的接口interface Square extends Shape { sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 123interface 新的接口 extends 接口1, 接口2 { 新增的属性: 类型} 例子： 12345678910111213141516interface Shape { color: string;}interface PenStroke { penWidth: number;}// 继承多个接口interface Square extends Shape, PenStroke { sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 混合类型一个对象可以同时做为函数和对象使用，并带有额外的属性。 1234567891011121314151617interface Counter { (start: number): string; interval: number; reset(): void;}function getCounter(): Counter { let counter = &lt;Counter&gt;function (start: number) { console.log(start) }; counter.interval = 123; counter.reset = function () { console.log('reset') }; return counter;}// 生成的c是一个函数，并且有额外属性let c = getCounter();c(10); // 10c.reset(); //resetc.interval = 5.0; // 5 接口继承类12345678910111213141516171819202122232425class Control { private state: any;}// 接口继承类interface SelectableControl extends Control { select(): void;}class Button extends Control implements SelectableControl { select() { }}class TextBox extends Control { select() { }}// 错误：“Image”类型缺少“state”属性。// 不行的原因就在于类必须要继承一次才能再使用接口实现class Image implements SelectableControl { select() { }}class Location {}","link":"/2020/05/26/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%80/"},{"title":"Typescript系列课程(二)","text":"本次主要讲的内容： 类 类 继承 公共，私有与受保护的修饰符 公共修饰符 public 私有修饰符 private 保护修饰符 protected 只读修饰符 readonly 存取器 静态属性 抽象类 高级技巧 构造函数 把类当做接口使用 函数 函数 函数类型 为函数定义类型 书写完整函数类型 可选参数和默认参数 剩余参数 this this参数 this参数在回调函数里 重载 泛型 泛型之Hello World 使用泛型变量 泛型类型 泛型类 泛型约束 在泛型约束中使用类型参数 在泛型里使用类类型 快速上手：点我跳转 Typescript文档地址：点我跳转 练习地址：点我跳转 类传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 类一个使用类的例子： 123456789101112131415// 定义一个Greeter的类class Greeter { // 属性 greeting: string; // new 的时候运行 constructor(message: string) { this.greeting = message; } // 方法 greet() { return \"Hello, \" + this.greeting; }}// 实例化let greeter = new Greeter(\"world\"); 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个greet方法。 你会注意到，我们在引用任何一个类成员的时候都用了this。 它表示我们访问的是类的成员。 最后一行，我们使用new构造了Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个Greeter类型的新对象，并执行构造函数初始化它。 继承一个例子： 12345678910111213141516171819// 定一个animal类class Animal { // 有一个移动方法 move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); }}// 定义一个dog类继承animal类class Dog extends Animal { // 定一个犬吠的方法 bark() { console.log('Woof! Woof!'); }}// 实例化const dog = new Dog();dog.bark();dog.move(10);dog.bark(); 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自Animal基类，通过 extends关键字。 派生类通常被称作子类，基类通常被称作 超类。 因为Dog继承了Animal的功能，因此我们可以创建一个Dog的实例，它能够bark()和move()。 12345678910111213141516171819202122232425262728293031// 我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。// 超类 Animalclass Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); }}// 子类 Snake 继承 Animalclass Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); }}class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(\"Galloping...\"); super.move(distanceInMeters); }}let sam = new Snake(\"Sammy the Python\");let tom: Animal = new Horse(\"Tommy the Palomino\");sam.move();tom.move(34); 公共，私有与受保护的修饰符在上面的例子里，我们可以自由的访问程序里定义的成员。在TypeScript里，成员都默认为 public。 公共修饰符 public写法： 1234567class 类名 { public 属性名: 类型}//或class 类名 { 属性名: 类型} public表示这个属性是可见的公有属性 123456789class Animal { public name: string; public constructor(theName: string) { this.name = theName; } public move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); }}let dog = new Animal('柯基')dog.move(10) // 柯基 moved 10m. 私有修饰符 private写法： 123class 类名 { private 属性名: 类型} 当成员被标记成 private时，它就不能在声明它的类的外部访问。 123456class Animal { private name: string; constructor(theName: string) { this.name = theName; }}new Animal(\"Cat\").name; // 错误: 'name' 是私有的. TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。 1234567891011121314151617181920class Animal { private name: string; constructor(theName: string) { this.name = theName; }}class Rhino extends Animal { constructor() { super(\"Rhino\"); }}class Employee { private name: string; constructor(theName: string) { this.name = theName; }}let animal = new Animal(\"Goat\"); //constructor: ƒ Animal(theName)let rhino = new Rhino();let employee = new Employee(\"Bob\"); //ƒ Employee(theName)animal = rhino; //因为Rhino是Animal的子类所以可以兼容animal = employee; // 错误: Animal 与 Employee 不兼容. Rhino是Animal的子类，所以它继承了Animal的私有属性。因为 Animal和 Rhino共享了来自Animal里的私有成员定义 private name: string，因此它们是兼容的。然而employee来自Employee，并不继承自Animal，所以即便有相同名称的私有属性name也是不可以的。 保护修饰符 protected写法： 123class 类名 { protected 属性名: 类型} protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如： 123456789101112131415161718192021class Person { protected name: string; constructor(name: string) { this.name = name; }}class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; }}let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch()); //由于Employee是派生自Person的，所以可以访问通过实例方法访问protected属性nameconsole.log(howard.name); // 错误 name是被保护的，只能在Person和subClasses中有权限访问 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如， 123456789101112131415161718192021class Person { protected name: string; protected constructor(theName: string) { this.name = theName; } //把构造函数设置成protected}// Employee 能够继承 Personclass Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; }}let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的. 只读修饰符 readonly你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 写法： 123class 类名 { readonly 属性名: 类型} 例子： 12345678910// 定义了一个章鱼classclass Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; }}let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 参数属性12345class 类名 { constructor (readonly 属性名: 类型) { }} 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性： 1234567class Octopus { readonly numberOfLegs: number = 8; constructor(readonly name: string) { } //设置一个只读参数name}let dad = new Octopus(\"Man with the 8 strong legs\");console.log(dad.name) //Man with the 8 strong legs 注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处 存取器 getters/settersTypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 首先，我们从一个没有使用存取器的例子开始。 123456789class Employee { fullName: string;}let employee = new Employee();employee.fullName = \"Bob Smith\"; //设置名字if (employee.fullName) { console.log(employee.fullName); //Bob Smith} 下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。 1234567891011121314151617181920212223242526let passcode = \"secret passcode\";class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode &amp;&amp; passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } }}let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) { alert(employee.fullName); // Bob Smith}// 如果我们在这里修改了 passcode变量，则不会弹出alert而是打印 Error: Unauthorized update of employee! 对于存取器有下面几点需要注意的： 首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性 static到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 写法 123class 类名 { static 属性 = 属性值} 例子： 12345678910111213141516// 定义一个栅格的类class Grid { static origin = {x: 0, y: 0}; //定一个静态属性orign calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); //origin只能通过Gride访问，不能用this否则会报错 let yDist = (point.y - Grid.origin.y);//origin只能通过Gride访问，不能用this否则会报错 return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; //Math.sqrt() 函数返回一个数的平方根， } constructor (public scale: number) { }}let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); //14.142135623730951console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); //2.8284271247461903 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。 抽象类 abstract抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。 写法： 123abstract class 类名 { abstract 方法(参数类型):返回类型} 例子： 123456abstract class Animal { abstract makeSound(): void; //抽象方法，只描述不实现 必须在派生类中实现 move(): void { console.log('roaming the earch...'); }} 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。 有几个规则: 抽象类可以直接赋值，允许创建一个对抽象类型的引用 不能创建一个抽象类的实例 允许对一个抽象子类进行实例化和赋值 在抽象子类中定义但在抽象类中没有声明的方法实例化后不能使用 抽象类中的abstract定义的方法必须在派生类中实现 在派生类的构造函数中必须调用 super() 123456789101112131415161718192021222324252627282930313233abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现}class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); }}let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧构造函数当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西 类的实例的类型。 构造函数的值。 类具有 实例部分与 静态部分这两个部分 12345678910111213class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; }}let greeter: Greeter; //Greeter类的实例的类型是 Greetergreeter = new Greeter(\"world\");console.log(greeter.greet()); //Hello, world 把类当做接口使用类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678910class Point { x: number; y: number;}interface Point3d extends Point { z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3}; 函数TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。 函数类型为函数定义类型123456// 带函数名的函数function add(x: number, y: number): number { return x + y;}// 赋值的匿名函数let myAdd = function(x: number, y: number): number { return x + y; }; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。 12// 不带返回值的写法let myAdd = function(x: number, y: number){ return x + y; }; 书写完整函数类型写法： 1(参数名: 类型, 参数名: 类型) =&gt; 返回值类型 例子： 123// 这个写法和上面为函数定义类型的写法效果实际上是一样的let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number { return x + y; }; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 123// baseValue -&gt; x increment-&gt; ylet myAdd: (baseValue: number, increment: number) =&gt; number = function(x: number, y: number): number { return x + y; }; 可选参数和默认参数传递给一个函数的参数个数必须与函数期望的参数个数一致。如果有的参数是可传可不传的则使用可选参数 可选参数写法： 123function (参数? : 类型) { //...} 例子： 12345678910function buildName(firstName: string, lastName?: string) { if (lastName) return firstName + \" \" + lastName; else return firstName;}let result1 = buildName(\"Bob\"); //oklet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数多了let result3 = buildName(\"Bob\", \"Adams\"); // ok 默认值可以给函数参数设置默认值，就跟es6一样 写法： 123function (参数=值) { //...} 例子： 12345678function buildName(firstName: string, lastName = \"Smith\") { return firstName + \" \" + lastName;}let result1 = buildName(\"Bob\"); // ok, returns \"Bob Smith\"let result2 = buildName(\"Bob\", undefined);// ok, returns \"Bob Smith\"let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数多了let result4 = buildName(\"Bob\", \"Adams\"); // ok 剩余参数123456function buildName(firstName: string, ...restOfName: string[]) { // 收集剩余参数到restOfName里 return firstName + \" \" + restOfName.join(\" \");}let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); //Joseph Samuel Lucas MacKinzie thisthis参数123456789101112131415161718192021222324252627282930// 定义一张牌的接口interface Card { suit: string; card: number;}// 定义一副牌的接口interface Deck { suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;}// 设置一副牌let deck: Deck = { suits: [\"红桃\", \"黑桃\", \"梅花\", \"方块\"], //花色 cards: Array(52), //牌 // 注意:该函数现在显式地指定它的被调用方必须是Deck类型，指定this类型为Deck createCardPicker: function(this: Deck) { return () =&gt; { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } }}let cardPicker = deck.createCardPicker();let pickedCard = cardPicker(); //抽到排alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); this参数在回调函数里当你将一个函数传递到某个库函数里稍后会被调用时，你可能会看到this报错 1234567891011121314interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void;}let uiElement:UIElementclass Handler { info: string; onClickBad(this: Handler, e: Event) { // oops, used this here. using this callback would crash at runtime this.info = e.message; }}let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 认为这个this的类型不匹配 修改 1234567891011121314interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void;}let uiElement:UIElementclass Handler { info: string; onClickBad = (e: Event) =&gt; { // 改为箭头函数即可，否则必须传入this为void类型 this.info = e.message; }}let h = new Handler();uiElement.addClickListener(h.onClickBad); 重载为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 举个例子：有个方法，传入数组，则从数组中抽一张牌。如果传入一个数字，则返回这个数字对应的花色和牌面数字。 下面这个例子没有使用重载 1234567891011121314151617181920212223let suits = [\"红桃\", \"黑桃\", \"梅花\", \"方块\"];function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; }}let myDeck = [{ suit: \"方块\", card: 2 }, { suit: \"黑桃\", card: 10 }, { suit: \"红桃\", card: 4 }];// 在调用方法的时候不会给有类型提示let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);// 在调用方法的时候不会给有类型提示let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 使用重载： 12345678910111213141516171819202122232425262728293031323334353637let suits = [\"红桃\", \"黑桃\", \"梅花\", \"方块\"];function pickCard(x: {suit: string; card: number; }[]): number; //重载，如果传入一个牌的对象，则返回值张牌在牌堆里的下标function pickCard(x: number): {suit: string; card: number; }; //重载，如果传入一个数字，则返回一张对应花色和数字的牌function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; }}let myDeck = [{ suit: \"方块\", card: 2 }, { suit: \"黑桃\", card: 10 }, { suit: \"红桃\", card: 4 }];// 在调用方法的时候会给有类型提示 /*function pickCard(x: { suit: string; card: number;}[]): number (+1 overload)*/let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);// 在调用方法的时候会给有类型提示/*function pickCard(x: number): { suit: string; card: number;} (+1 overload)*/let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 泛型在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 泛型之Hello World1234// 假设我们想使用数字类型function identity(arg: number): number { return arg;} 使用泛型变量泛型类型泛型类泛型约束在泛型约束中使用类型参数在泛型里使用类类型","link":"/2020/05/29/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%BA%8C/"}],"tags":[{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"}],"categories":[{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"}]}