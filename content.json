{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/22/hello-world/"},{"title":"标记插件rough-notation","text":"插件地址：https://roughnotation.com/ 通过它的官网可以查看标记的效果。 一个用于在web页面上创建和动画注释的小型JavaScript库。 Rough Notation使用RoughJS创建手绘外观。元素可以用许多不同的样式进行注释。动画持续时间和延迟可以配置，或只是关闭。 gzip压缩时大概占3.3kb。 点击跳转官网的源码 github地址 安装npm 1npm install --save rough-notation ES module 1&lt;script type=\"module\" src=\"https://unpkg.com/rough-notation?module\"&gt;&lt;/script&gt; IIFE 版本会创建 RoughNotation 对象在你的scope 1&lt;script type=&quot;module&quot; src=&quot;https://unpkg.com/rough-notation/lib/rough-notation.iife.js&quot;&gt;&lt;/script&gt; 使用创建一个标记 annotation 对象，挂在在元素上，然后可以使用show()或hide()来控制 12345import { annotate } from 'rough-notation';const e = document.querySelector('#myElement');const annotation = annotate(e, { type: 'underline' });annotation.show(); 配置 Annotation创建 Annotation 对象时，传入一个配置。配置只有一个强制字段type。您可以灵活的对其进行配置。 type这是一个强制的字段，它规定了annotation的样式。下面列出了type的类型: underline: 下划线 box: 给元素画一个方块 circle: 在元素上画一个圈 highlight: 创建一个高亮马克笔标记 strike-through: 此样式在元素周围绘制一个框。 crossed-off: 此样式在元素周围绘制一个框。 样式图例： animateBoolean | default: true | 控制是否开启动画 animationDurationNumber | default: 800 | 单位是毫秒 animationDelayNumber | default: 0 | 单位是毫秒 color颜色色值 | 控制颜色 1const a1 = annotate($('#groupSection h3'), { type: 'box', color: '#BF360C' }); strokeWidthNumber | default: 1 | 宽度 paddingdefault：5如果您希望指定不同的顶部、左侧、右侧、底部，您可以将该值设置为类似于CSS样式padidng [top, right, bottom, left]或[top &amp; bottom, left &amp; right]的数组。 1const a4 = annotate($('header span.acircle'), { type: 'circle', color: '#F44336', padding: 2 }); Annotation Object 方法名 功能 isShowing() 返回是否正在显示 show() 显示并开始执行动画 hide() 隐藏，没有动画 remove() 移除元素和标记的关联 示例： 12345678910const annotate = RoughNotation.annotate;const annotationGroup = RoughNotation.annotationGroup;const config = { type: 'underline', strokeWidth: 3, padding: 3, color: '#B71C1C' };const a1 = annotate($('#underlineSection h3'), config); // annotate Objectconst a2 = annotate($('#underlineSection span'), config); // annotate Object$('#underlineSection button').addEventListener('click', () =&gt; { a1.show(); //显示 a2.show(); //显示}); Annotation Group Object当您调用annotationGroup函数时，您将返回一个annotation group对象，该对象具有以下方法: 方法名 功能 show() 按顺序绘制所有注释。如果注释被设置为animate(默认)，它将使绘图具有动画效果。如果再次调用，它将重新绘制动画。 hide() 如果显示，则隐藏所有标记。这不是动画。","link":"/2020/06/03/%E6%A0%87%E8%AE%B0%E6%8F%92%E4%BB%B6roughnotation/"},{"title":"Typescript系列课程(一)","text":"本次主要讲的内容： 基础类型 布尔值 数字 字符串 数组 Any Void Null 和 Undefined Object 元组Tuple 枚举 Never 类型断言 接口 一个例子 可选属性 只读属性 额外属性检查 函数类型 可索引的类型 类类型 继承接口 混合类型 接口继承类 快速上手：点我跳转 Typescript文档地址：点我跳转 练习地址：点我跳转 基础类型布尔值1let isDone: boolean = false; 数字1let decLiteral: number = 6; 字符串12let name: string = \"bob\";name = \"smith\"; 模板字符串 12345let name: string = `Gene`;let age: number = 37;let sentence: string = `Hello, my name is ${ name }.I'll be ${ age + 1 } years old next month.`; 输出： 123Hello, my name is Gene.I'll be 38 years old next month. 数组方式一：直接指定类型 12//例如：定义一个数字类型的数组let list: number[] = [1, 2, 3]; 方式二：使用泛型 12345//使用数组泛型，Array&lt;元素类型&gt;// 定义一个数字的let list: Array&lt;number&gt; = [1, 2, 3]; // 定义一个字符串的let list: Array&lt;string&gt; = ['a','b','c']; Any有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。 这些值可能来自于动态的内容，比如来自用户输入或第三方代码库。 这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。 那么我们可以使用 any类型来标记这些变量： 总结：就是你也不知道什么类型用any 123let notSure: any = 4;notSure = \"maybe a string instead\";notSure = false; //这样也是可以定义的，因为没有固定类型 在对现有代码进行改写的时候，any类型是十分有用的，它允许你在编译时可选择地包含或移除类型检查。 你可能认为 Object有相似的作用，就像它在其它语言中那样。 但是 Object类型的变量只是允许你给它赋任意值 - 但是却不能够在它上面调用任意的方法，即便它真的有这些方法： 123456let notSure: any = 4;notSure.ifItExists(); // ok，ifItExists 这个方法可能在执行时存在notSure.toFixed(); // ok, toFixed存在 (但是编译器不会检查)let prettySure: Object = 4;prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'. Void某种程度上来说，void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void： 1234function warnUser(): void { console.log(\"这是一条警告消息\");}//这个方法没有返回值 Null 和 Undefined12345//我们不能再给这些变量赋值let u: undefined = undefined;let n: null = null;u=123 //报错 Objectobject表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型 1234567891011// 声明一个create方法 参数为object或null 没有返回值declare function create(o: object | null): void;create({ prop: 0 }); // OKcreate(null); // OKcreate(42); // Errorcreate(\"string\"); // Errorcreate(false); // Errorcreate(undefined); // Errorcreate(); //Error 元组Tuple元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。 123456// Declare a tuple typelet x: [string, number];x = ['hello', 10]; // OKx = [10, 'hello']; // Error 当访问一个已知索引的元素，会得到正确的类型： 12console.log(x[0].substr(1)); // OKconsole.log(x[1].substr(1)); // Error, 'number' does not have 'substr' 当访问一个越界的元素，会使用联合类型替代： 12345x[3] = 'world'; // OK, 字符串可以赋值给(string | number)类型, 因为之前的两个类型是number类型和string类型console.log(x[5].toString()); // OK, 'string' 和 'number' 都有 toStringx[6] = true; // Error, 布尔不是(string | number)类型 枚举enum类型是对JavaScript标准数据类型的一个补充。 像C#等其它语言一样，使用枚举类型可以为一组数值赋予友好的名字。 12enum Color {Red, Green, Blue}let c: Color = Color.Green; //1 默认情况下，从0开始为元素编号。 你也可以手动的指定成员的数值。 例如，我们将上面的例子改成从 1开始编号： 12enum Color {Red = 1, Green, Blue}let c: Color = Color.Green; //2 或者，全部都采用手动赋值： 12enum Color {Red = 1, Green = 2, Blue = 4}let c: Color = Color.Green; Nevernever类型表示的是那些永不存在的值的类型。 123456789101112131415// 返回never的函数必须存在无法达到的终点function error(message: string): never { throw new Error(message);}// 推断的返回值类型为neverfunction fail() { return error(\"Something failed\");}// 返回never的函数必须存在无法达到的终点function infiniteLoop(): never { while (true) { }} 类型断言通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。 有两种写法： 写法一：尖括号 123let someValue: any = \"this is a string\";let strLength: number = (&lt;string&gt;someValue).length; 写法二：as（推荐） 123let someValue: any = \"this is a string\";let strLength: number = (someValue as string).length; 当你在TypeScript里使用JSX时，只有 as语法断言是被允许的。 接口在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。 基本使用举个例子： 123456function printLabel(labelledObj: { label: string }) { console.log(labelledObj.label);}let myObj = { size: 10, label: \"Size 10 Object\" };printLabel(myObj); 类型检查器会查看printLabel的调用。 printLabel有一个参数，并要求这个对象参数有一个名为label类型为string的属性。 这个时候我们就可以使用接口写法代替上面的写法 基本接口写法： 123interface 接口名 { 属性名: 类型;} 注意： 如果使用这个接口的话，不能传入额外的属性，如果需要传入额外的属性，参考后面的额外属性检查 通过接口写法我们可以把上面的例子改成下面这样： 1234567891011// 定义一个名为LabelledValue的接口interface LabelledValue { label: string;}// 定义printLabelfunction printLabel(labelledObj: LabelledValue) { console.log(labelledObj.label);}let myObj = {size: 10, label: \"Size 10 Object\"};printLabel(myObj); //Size 10 Objec 可选属性可选属性的好处之一是可以对可能存在的属性进行预定义，好处之二是可以捕获引用了不存在的属性时的错误。 写法：在属性名后面增加一个？ 123interface 接口名 { 属性名?: 类型;} 123456789101112131415161718192021// 定一个一个可选属性接口interface SquareConfig { color?: string; width?: number;}// 创建一个正方形 传入颜色和宽度，返回颜色和面积function createSquare(config: SquareConfig): {color: string; area: number} { // 默认 白色 100 let newSquare = {color: \"white\", area: 100}; if (config.color) { newSquare.color = config.color; } if (config.width) { newSquare.area = config.width * config.width; } return newSquare;}let mySquare = createSquare({color: \"black\"}); //{ area: 100, color: 'black' }mySquare = createSquare({color: \"black\", width: 2});//{ area: 4, color: 'black' } 只读属性一些对象属性只能在对象刚刚创建的时候修改其值 写法：属性名前加readonly 123interface 接口名 { readonly 属性名: 类型;} 12345678interface Point { readonly x: number; readonly y: number;}// 定义一个p1变量，使用point接口let p1: Point = { x: 10, y: 20 };//修改x的值p1.x = 5; // error! 设置只读数组TypeScript具有ReadonlyArray&lt;T&gt;类型，它与Array&lt;T&gt;相似，只是把所有可变方法去掉了，因此可以确保数组创建后再也不能被修改： 1234567let a: number[] = [1, 2, 3, 4];let ro: ReadonlyArray&lt;number&gt; = a;console.log(ro[0]) // ok，可以读取ro[0] = 12; // error!ro.push(5); // error!ro.length = 100; // error!a = ro; // error! 上面代码的最后一行，可以看到就算把整个ReadonlyArray赋值到一个普通数组也是不可以的。 想要改成普通类型，只能使用类型断言重写 1a = ro as number[]; readonly vs const最简单判断该用readonly还是const的方法是看要把它做为变量使用还是做为一个属性。 做为变量使用的话用 const，若做为属性则使用readonly。 额外属性检查先看一个例子： 123456789101112// 定义一个可选属性的接口interface SquareConfig { color?: string; width?: number;}function createSquare(config: SquareConfig): void { console.log(config.color) //undefined console.log(config.width) // 100}//这里我们假设打错了一个属性color -&gt; colourlet mySquare = createSquare({ colour: \"red\", width: 100 }); 这里程序会认为你设置的属性不对，ts会给colour有个红线，即便是可选属性。 我们有三个方案可以绕开这个检测： 方案一：使用断言 1let mySquare = createSquare({ width: 100, opacity: 0.5 } as SquareConfig); 方案二：重新赋值 12let squareOptions = { colour: \"red\", width: 100 };let mySquare = createSquare(squareOptions); 方案三：使用额外属性写法 123456//如果 SquareConfig带有上面定义的类型的color和width属性，并且还会带有任意数量的其它属性，那么我们可以这样定义它interface SquareConfig { color?: string; width?: number; [propName: string]: any;} 函数类型定义一个函数类型的接口 123interface 接口名 { (参数1: 类型, 参数2: 类型): 返回值类型} 举个例子 1234567891011// 定义一个接口，接受两个参数：字符串的source 和 字符串的subString 结果返回布尔类型interface SearchFunc { (source: string, subString: string): boolean;}// 设置接口类型let mySearch: SearchFunc;// 定义方法mySearch = function(source: string, subString: string) { let result = source.search(subString); return result &gt; -1;} 对于函数类型的类型检查来说，函数的参数名不需要与接口里定义的名字相匹配。函数的参数会逐个进行检查，要求对应位置上的参数类型是兼容的。 比如，我们使用下面的代码重写上面的例子： 12345678910interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc;// 这里参数名称变成src 和 sub了mySearch = function(src: string, sub: string): boolean { let result = src.search(sub); return result &gt; -1;} 如果你不想指定类型，TypeScript的类型系统会推断出参数类型 12345678910interface SearchFunc { (source: string, subString: string): boolean;}let mySearch: SearchFunc;mySearch = function(src, sub) { let result = src.search(sub); return result &gt; -1;}//因为函数直接赋值给了 SearchFunc类型变量。 函数的返回值类型是通过其返回值推断出来的（此例是 false和true）。 如果让这个函数返回数字或字符串，类型检查器会警告我们函数的返回值类型与 SearchFunc接口中的定义不匹配。 可索引的类型与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap[&quot;daniel&quot;]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。 TypeScript支持两种索引签名：字符串和数字 数字索引签名 12345678interface StringArray { [index: number]: string; //数字索引签名}let myArray: StringArray;myArray = [\"Bob\", \"Fred\"];let myStr: string = myArray[0]; 字符串索引签名 12345678interface Animal { [name: string]: string //字符串索引签名}let dog: Animal = { name: 'dog', //只能设置值为string类型 age: 44 //error 不能设置值为数字} 类类型实现接口TypeScript也能够用它来明确的强制一个类去符合某种契约。 注：接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。 123456789101112interface ClockInterface { currentTime: Date; setTime(d: Date); //描述一个方法站在类里实现它}class Clock implements ClockInterface { currentTime: Date; setTime(d: Date) { this.currentTime = d; } constructor(h: number, m: number) { }} 类静态部分与实例部分的区别当你操作类和接口的时候，你要知道类是具有两个类型的：静态部分的类型和实例的类型。 123456789101112131415161718192021222324252627282930//用于构造函数的interface ClockConstructor { new (hour: number, minute: number): ClockInterface;}// 用于实例方法的interface ClockInterface { tick();}// 工厂函数function createClock(ctor: ClockConstructor, hour: number, minute: number): ClockInterface { return new ctor(hour, minute);}// 定义一个数字钟class DigitalClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"beep beep\"); }}// 定义一个模拟时钟class AnalogClock implements ClockInterface { constructor(h: number, m: number) { } tick() { console.log(\"tick tock\"); }}// 调用工厂函数实例化let digital = createClock(DigitalClock, 12, 17);let analog = createClock(AnalogClock, 7, 32); 继承接口和类一样，接口也可以相互继承。 这让我们能够从一个接口里复制成员到另一个接口里，可以更灵活地将接口分割到可重用的模块里。 1234567891011interface Shape { color: string;}// 继承Shape接口形成一个新的接口interface Square extends Shape { sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10; 一个接口可以继承多个接口，创建出多个接口的合成接口。 123interface 新的接口 extends 接口1, 接口2 { 新增的属性: 类型} 例子： 12345678910111213141516interface Shape { color: string;}interface PenStroke { penWidth: number;}// 继承多个接口interface Square extends Shape, PenStroke { sideLength: number;}let square = &lt;Square&gt;{};square.color = \"blue\";square.sideLength = 10;square.penWidth = 5.0; 混合类型一个对象可以同时做为函数和对象使用，并带有额外的属性。 1234567891011121314151617interface Counter { (start: number): string; interval: number; reset(): void;}function getCounter(): Counter { let counter = &lt;Counter&gt;function (start: number) { console.log(start) }; counter.interval = 123; counter.reset = function () { console.log('reset') }; return counter;}// 生成的c是一个函数，并且有额外属性let c = getCounter();c(10); // 10c.reset(); //resetc.interval = 5.0; // 5 接口继承类12345678910111213141516171819202122232425class Control { private state: any;}// 接口继承类interface SelectableControl extends Control { select(): void;}class Button extends Control implements SelectableControl { select() { }}class TextBox extends Control { select() { }}// 错误：“Image”类型缺少“state”属性。// 不行的原因就在于类必须要继承一次才能再使用接口实现class Image implements SelectableControl { select() { }}class Location {}","link":"/2020/05/26/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%80/"},{"title":"Typescript系列课程(三)","text":"本次主要讲的内容： 枚举 数字枚举 字符串枚举 异构枚举（Heterogeneous enums） 计算的和常量成员 联合枚举与枚举成员的类型 运行时的枚举 反向映射 const枚举 外部枚举 类型推论 基础 最佳通用类型 上下文类型 类型兼容性 介绍 开始 比较两个函数 函数参数双向协变 可选参数及剩余参数 函数重载 枚举 类 类的私有成员和受保护成员 泛型 高级类型 交叉类型（Intersection Types） 联合类型（Union Types） 类型保护与区分类型（Type Guards and Differentiating Types） 用户自定义的类型保护 typeof类型保护 instanceof类型保护 可以为null的类型 可选参数和可选属性 类型保护和类型断言 类型别名 接口 vs. 类型别名 字符串字面量类型 数字字面量类型 枚举成员类型 可辨识联合（Discriminated Unions） 完整性检查 多态的 this类型 索引类型（Index types） 索引类型和字符串索引签名 映射类型 由映射类型进行推断 快速上手：点我跳转 Typescript文档地址：点我跳转 练习地址：点我跳转 枚举使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。 数字枚举数字枚举就是指枚举值都是数字。相当于定义一串key，key的值从上到下自增1。 写法： 12345enum 枚举类型 { 枚举属性1, //默认是0 如果需要设置默认值：枚举属性1=1设置枚举属性值从1开始 枚举属性2, ...} 例子： 123456enum Direction { Up = 1, //1 Down, //2 Left, //3 Right //4} 如上，我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4。 123456enum Direction { Up, // 0 Down, //1 Left, //2 Right, //3} 现在， Up的值为 0， Down的值为 1等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。 1234567891011enum Values { No = 0, Yes}function respond(recipient: string, message: Values): void { // 打印传入的值 console.log(recipient, message)}respond(\"Princess Caroline\", Values.Yes) //Princess Caroline 1 字符串枚举字符串是枚举值。定义的时候类似于定义对象。类似于数字枚举的写法，只不过传入的值为字符串。 12345678910enum Direction { Up = \"UP\", Down = \"DOWN\", Left = \"LEFT\", Right = \"RIGHT\",}alert(Direction.Up) //UPalert(Direction.Down) //DOWNalert(Direction.Left) //LEFTalert(Direction.Right) //RIGHT 由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管 反向映射 会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。 异构枚举（Heterogeneous enums）就是混合使用数字和字符串作为枚举值。不建议使用 1234enum BooleanLikeHeterogeneousEnum { No = 0, Yes = \"YES\",} 计算的和常量成员每个枚举成员都带有一个值，它可以是 常量或 计算出来的。 当满足如下条件时，枚举成员被当作是常量： 它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 012enum E { X }// E.X 为常量0 它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1123456enum E2 { A = 1, B, C}// E.A 为常量1// E.B 为常量2// E.C 为常量3 枚举成员使用常量枚举表达式初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式： 一个枚举表达式字面量（主要是字符串字面量或数字字面量) 一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的） 带括号的常量枚举表达式 一元运算符 +, -,~其中之一应用在了常量枚举表达式 常量枚举表达式做为二元运算符 +, -, *, /, %, &lt;&lt;, &gt;&gt;, &gt;&gt;&gt;, &amp;, |, ^的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。 例如： 12345678910111213enum E1 { B = 2}enum E2 { A = 1, //一个枚举表达式数字字面量 B = E1.B, //一个对之前定义的常量E1枚举成员B的引用 D = 1 &lt;&lt; 1, //结果：2 数字1向左移动一位 F = B | D //常量枚举表达式做为二元运算符|}console.log(E2.A) //1console.log(E2.B) //2console.log(E2.D) //2console.log(E2.F) //2 所有其它情况的枚举成员被当作是需要计算得出的值。 123456789enum FileAccess { // 常量成员 None, Read = 1 &lt;&lt; 1, Write = 1 &lt;&lt; 2, ReadWrite = Read | Write, // 计算成员 G = \"123\".length} 联合枚举与枚举成员的类型首先，枚举成员成为了类型。我们可以说某些成员 只能是枚举成员的值： 12345678910111213141516171819enum ShapeKind { Circle, Square,}interface Circle { kind: ShapeKind.Circle; radius: number;}interface Square { kind: ShapeKind.Square; sideLength: number;}let c: Circle = { kind: ShapeKind.Square, //kind报错：只能是Circle中的kind，也就是说必须是ShapeKind的枚举值ShapeKind.Circle。因为限定了变量c的类型，而类型接口中确定了kind属性的值 radius: 100,} 另一个变化是枚举类型本身变成了每个枚举成员的 联合（在高级类型中会讲）。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如： 1234567891011enum E { Foo, Bar,}function f(x: E) { if (x !== E.Foo || x !== E.Bar) { // ~~~~~~~~~~~ // Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.这个条件将永远返回true，因为这两个值涵盖了枚举E所有情况 }} 这个例子里，我们先检查x是否不是 E.Foo。 如果通过了这个检查，然后 ||会发生短路效果， if语句体里的内容会被执行。 然而，这个检查没有通过，那么 x则 只能为 E.Foo，因此没理由再去检查它是否为 E.Bar 运行时的枚举枚举是在运行时真正存在的对象。它可以传递给函数。 123456789enum E { X, Y, Z}function f(obj: { X: number }) { return obj.X;}// 可以，因为E有一个名为X的属性，它是一个数字。f(E); 反向映射可以用枚举返回的值映射会枚举的key 123456enum Enum { A}let a = Enum.A;let nameOfA = Enum[a]; // \"A\"// 生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。 注意：不会为字符串枚举成员生成反向映射 const枚举大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 const枚举。 常量枚举通过在枚举上使用 const修饰符来定义。 1234const enum Enum { A = 1, B = A * 2} 常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。简单说就是这种常量的枚举，在编译的时候会直接把枚举值放入对应使用的地方。 12345678const enum Directions { Up, Down, Left, Right}let directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right] 编译后的代码为 1var directions = [0 /* Up */, 1 /* Down */, 2 /* Left */, 3 /* Right */]; 外部枚举外部枚举用来描述已经存在的枚举类型的形状。外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。 123456// 声明一个枚举类型，常用在声明文件中declare enum Enum { A = 1, B, // 不带declare时会认为这个是常熟成员，此时它被认为是需要经过计算的 C = 2} 类型推论即，类型是在哪里如何被推断的。 基础TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子 1let x = 3; //变量x的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。 最佳通用类型当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如 1let x = [0, 1, null]; 为了推断x的类型，我们必须考虑所有元素的类型。 这里有两种选择： number和null。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。 1let zoo = [new Rhino(), new Elephant(), new Snake()]; //推断为 (Rhino | Elephant | Snake)[] 这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型： 1let zoo: Animal[] = [new Rhino(), new Elephant(), new Snake()]; //Animal[] 上下文类型TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。 类型兼容性我们使用了“兼容性”，它在语言规范里没有定义。 在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和any来回赋值，以及enum和对应数字值之间的来回赋值。 语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在implements和extends语句也不例外。 介绍在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。用人话说就是typescript只在意你的类型组成的结果，不强制要求对class声明类类型。 1234567891011interface Named { name: string;}class Person { name: string;}let p: Named;// OK, 因为组成的结构类型中有namep = new Person(); 开始TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。比如： 1234567891011121314151617interface Named { name: string;}let x: Named;// y's inferred type is { name: string; location: string; }// 如果这里直接给x赋值下面这个字面量对象会报x的类型错误let y = { name: 'Alice', location: 'Seattle' };// 关键点：这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。x = y;// 检查函数参数时使用相同的规则：function greet(n: Named) { // 注意，y有个额外的location属性，但这不会引发错误。 只有目标类型（这里是Named）的成员会被一一检查是否兼容。 console.log('Hello, ' + n.name);}greet(y); // OK 比较两个函数对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。 123456789101112let x = (a: number) =&gt; 0;let y = (b: number, s: string) =&gt; 0;/** * 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只*看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。 **/y = x; // OK/** * 因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。 */x = y; // Error 类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。 函数参数双向协变当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如： 123456789101112131415161718192021enum EventType { Mouse, Keyboard }interface Event { timestamp: number; }interface MouseEvent extends Event { X: number; Y: number }interface KeyEvent extends Event { keyCode: number }function listenEvent(eventType: EventType, handler: (n: Event) =&gt; void) { /* ... */ let target = document.querySelector('body') target.addEventListener('click', handler)}// 不健全，但有用并且常见listenEvent(EventType.Mouse, (e: MouseEvent) =&gt; console.log(e.x + ',' + e.y));// 传入的是一个不准确的类型，但是使用的时候确是含有更多类型信息的类型。比如MouseEvent的类型信息是多于Event的listenEvent(EventType.Mouse, (e: Event) =&gt; console.log((&lt;MouseEvent&gt;e).x + ',' + (&lt;MouseEvent&gt;e).y));listenEvent(EventType.Mouse, &lt;(e: Event) =&gt; void&gt;((e: MouseEvent) =&gt; console.log(e.x + ',' + e.y)));// 需要的是Event却传入的numberlistenEvent(EventType.Mouse, (e: number) =&gt; console.log(e)); //Error 可选参数及剩余参数比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。 剩余参数：当一个函数有剩余参数时，它被当做无限个可选参数。 可选参数：这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。 有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用： 12345678910function invokeLater(args: any[], callback: (...args: any[]) =&gt; void) { /* ... Invoke callback with 'args' ... */ callback(args)}// 不可靠 - invokeLater \"might\" provide any number of argumentsinvokeLater([1, 2], (x, y) =&gt; console.log(x + ', ' + y)); //1,2// 让人困惑 (x and y are 事实上是需要的) and 非显示的invokeLater([1, 2], (x?, y?) =&gt; console.log(x + ', ' + y)); //1,2 函数重载对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。 枚举 枚举类型与数字类型兼容 数字类型与枚举类型兼容 不同枚举类型之间是不兼容的 比如: 1234567enum Status { Ready, Waiting };enum Color { Red, Blue, Green };let _status = Status.Ready;let a:number = _status; //数字类型与枚举类型兼容_status = Color.Green; // Error 不同枚举类型之间是不兼容的_status = 3; //数字类型与枚举类型兼容 类类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。 TS中类的静态部分指的是这个类（函数）本身，实例部分指的是类实例化出来的对象 123456789101112131415class Animal { feet: number; //只检查feet constructor(name: string, numFeet: number) { } //不检查}class Size { feet: number; //只检查feet constructor(numFeet: number) { } //不检查}let a: Animal;let s: Size;a = s; // OKs = a; // OK 类的私有成员和受保护成员类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。 泛型因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如 123456interface Empty&lt;T&gt; {}let x: Empty&lt;number&gt;;let y: Empty&lt;string&gt;;x = y; // OK, because y matches structure of x 上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了： 1234567interface NotEmpty&lt;T&gt; { data: T;}let x: NotEmpty&lt;number&gt;;let y: NotEmpty&lt;string&gt;;x = y; // Error, x 和 y不兼容了 在这里，泛型类型在使用时就好比不是一个泛型类型。 高级类型交叉类型（Intersection Types）交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。 写法： 1类型1 &amp; 类型2 &amp; 类型3 例子： 1234567891011121314151617181920212223242526272829// 定一个继承方法，可以将两个对象合并// 这里定义了一个交叉类型 T &amp; Ufunction extend&lt;T, U&gt;(first: T, second: U): T &amp; U { let result = &lt;T &amp; U&gt;{}; for (let id in first) { (&lt;any&gt;result)[id] = (&lt;any&gt;first)[id]; } for (let id in second) { if (!result.hasOwnProperty(id)) { (&lt;any&gt;result)[id] = (&lt;any&gt;second)[id]; } } return result;}class Person { constructor(public name: string) { }}interface Loggable { log(): void;}class ConsoleLogger implements Loggable { log() { // ... }}var jim = extend(new Person(\"Jim\"), new ConsoleLogger());var n = jim.name;jim.log(); 联合类型（Union Types）联合类型与交叉类型类似，表示一串类型的或关系。可以是这一串类型中的任何一个。 写法： 1类型1 | 类型2 | 类型3 例如： 1234567891011121314151617/** * 在字符串的左面放一个 \"padding\". * If 'padding' is a string, 就把传入的'padding'放到左边. * If 'padding' is a number, 就把number*空格数放到文字左面. */function padLeft(value: string, padding: string | number) { if (typeof padding === \"number\") { return Array(padding + 1).join(\" \") + value; } if (typeof padding === \"string\") { return padding + value; } throw new Error(`Expected string or number, got '${padding}'.`);}padLeft(\"Hello world\", 4); // returns \" Hello world\"padLeft(\"Hello world\", \" \"); // returns \" Hello world\" 类型保护与区分类型（Type Guards and Differentiating Types）我们像确切的知道哪一个类型怎么处理？ 1234567891011121314151617181920212223242526// 定义一个鸟的接口interface Bird { fly(); layEggs();}// 定义一个鱼的接口interface Fish { swim(); layEggs();}function getSmallPet(): Fish | Bird { // ...}let pet = getSmallPet();pet.layEggs(); // okaypet.swim(); // errors// 可以使用断言处理if ((&lt;Fish&gt;pet).swim) { (&lt;Fish&gt;pet).swim();}else { (&lt;Bird&gt;pet).fly();} 用户自定义的类型保护假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。我们可以使用类型谓词解决： 写法： 12// parameterName必须是来自于当前函数签名里的一个参数名。parameterName is Type TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词： 123function isFish(pet: Fish | Bird): pet is Fish { return (&lt;Fish&gt;pet).swim !== undefined;} 在这个例子里， pet is Fish就是类型谓词。 谓词为parameterName is Type这种形式， parameterName必须是来自于当前函数签名里的一个参数名。 每当使用一些变量调用 isFish时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。 12345678// 'swim' 和 'fly' 调用都没有问题了if (isFish(pet)) { pet.swim();}else { pet.fly();} 注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型。 typeof类型保护同js中使用typeof一样，进行类型判断。但是只能判断”number”， “string”， “boolean”或 “symbol” 写法： 1234typeof v === \"typename\"// 或typeof v !== \"typename\"// \"typename\"必须是 \"number\"， \"string\"， \"boolean\"或 \"symbol\" instanceof类型保护可以为null的类型可选参数和可选属性类型保护和类型断言类型别名接口 vs. 类型别名字符串字面量类型数字字面量类型枚举成员类型可辨识联合（Discriminated Unions）完整性检查多态的 this类型索引类型（Index types）索引类型和字符串索引签名映射类型由映射类型进行推断","link":"/2020/06/08/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%89/"},{"title":"Typescript系列课程(二)","text":"本次主要讲的内容： 类 类 继承 公共，私有与受保护的修饰符 公共修饰符 public 私有修饰符 private 保护修饰符 protected 只读修饰符 readonly 存取器 静态属性 抽象类 高级技巧 构造函数 把类当做接口使用 函数 函数 函数类型 为函数定义类型 书写完整函数类型 可选参数和默认参数 剩余参数 this this参数 this参数在回调函数里 重载 泛型 泛型之Hello World 使用泛型变量 泛型类型 泛型类 泛型约束 在泛型约束中使用类型参数 在泛型里使用类类型 快速上手：点我跳转 Typescript文档地址：点我跳转 练习地址：点我跳转 类传统的JavaScript程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的。 从ECMAScript 2015，也就是ECMAScript 6开始，JavaScript程序员将能够使用基于类的面向对象的方式。 使用TypeScript，我们允许开发者现在就使用这些特性，并且编译后的JavaScript可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript版本。 类一个使用类的例子： 123456789101112131415// 定义一个Greeter的类class Greeter { // 属性 greeting: string; // new 的时候运行 constructor(message: string) { this.greeting = message; } // 方法 greet() { return \"Hello, \" + this.greeting; }}// 实例化let greeter = new Greeter(\"world\"); 我们声明一个 Greeter类。这个类有3个成员：一个叫做 greeting的属性，一个构造函数和一个greet方法。 你会注意到，我们在引用任何一个类成员的时候都用了this。 它表示我们访问的是类的成员。 最后一行，我们使用new构造了Greeter类的一个实例。 它会调用之前定义的构造函数，创建一个Greeter类型的新对象，并执行构造函数初始化它。 继承一个例子： 12345678910111213141516171819// 定一个animal类class Animal { // 有一个移动方法 move(distanceInMeters: number = 0) { console.log(`Animal moved ${distanceInMeters}m.`); }}// 定义一个dog类继承animal类class Dog extends Animal { // 定一个犬吠的方法 bark() { console.log('Woof! Woof!'); }}// 实例化const dog = new Dog();dog.bark();dog.move(10);dog.bark(); 这个例子展示了最基本的继承：类从基类中继承了属性和方法。 这里， Dog是一个 派生类，它派生自Animal基类，通过 extends关键字。 派生类通常被称作子类，基类通常被称作 超类。 因为Dog继承了Animal的功能，因此我们可以创建一个Dog的实例，它能够bark()和move()。 12345678910111213141516171819202122232425262728293031// 我们使用 extends关键字创建了 Animal的两个子类： Horse和 Snake。// 超类 Animalclass Animal { name: string; constructor(theName: string) { this.name = theName; } move(distanceInMeters: number = 0) { console.log(`${this.name} moved ${distanceInMeters}m.`); }}// 子类 Snake 继承 Animalclass Snake extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 5) { console.log(\"Slithering...\"); super.move(distanceInMeters); }}class Horse extends Animal { constructor(name: string) { super(name); } move(distanceInMeters = 45) { console.log(\"Galloping...\"); super.move(distanceInMeters); }}let sam = new Snake(\"Sammy the Python\");let tom: Animal = new Horse(\"Tommy the Palomino\");sam.move();tom.move(34); 公共，私有与受保护的修饰符在上面的例子里，我们可以自由的访问程序里定义的成员。在TypeScript里，成员都默认为 public。 公共修饰符 public写法： 1234567class 类名 { public 属性名: 类型}//或class 类名 { 属性名: 类型} public表示这个属性是可见的公有属性 123456789class Animal { public name: string; public constructor(theName: string) { this.name = theName; } public move(distanceInMeters: number) { console.log(`${this.name} moved ${distanceInMeters}m.`); }}let dog = new Animal('柯基')dog.move(10) // 柯基 moved 10m. 私有修饰符 private写法： 123class 类名 { private 属性名: 类型} 当成员被标记成 private时，它就不能在声明它的类的外部访问。 123456class Animal { private name: string; constructor(theName: string) { this.name = theName; }}new Animal(\"Cat\").name; // 错误: 'name' 是私有的. TypeScript使用的是结构性类型系统。 当我们比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，我们就认为它们的类型是兼容的。 然而，当我们比较带有 private或 protected成员的类型的时候，情况就不同了。 如果其中一个类型里包含一个 private成员，那么只有当另外一个类型中也存在这样一个 private成员， 并且它们都是来自同一处声明时，我们才认为这两个类型是兼容的。 对于 protected成员也使用这个规则。 1234567891011121314151617181920class Animal { private name: string; constructor(theName: string) { this.name = theName; }}class Rhino extends Animal { constructor() { super(\"Rhino\"); }}class Employee { private name: string; constructor(theName: string) { this.name = theName; }}let animal = new Animal(\"Goat\"); //constructor: ƒ Animal(theName)let rhino = new Rhino();let employee = new Employee(\"Bob\"); //ƒ Employee(theName)animal = rhino; //因为Rhino是Animal的子类所以可以兼容animal = employee; // 错误: Animal 与 Employee 不兼容. Rhino是Animal的子类，所以它继承了Animal的私有属性。因为 Animal和 Rhino共享了来自Animal里的私有成员定义 private name: string，因此它们是兼容的。然而employee来自Employee，并不继承自Animal，所以即便有相同名称的私有属性name也是不可以的。 保护修饰符 protected写法： 123class 类名 { protected 属性名: 类型} protected修饰符与 private修饰符的行为很相似，但有一点不同， protected成员在派生类中仍然可以访问。例如： 123456789101112131415161718192021class Person { protected name: string; constructor(name: string) { this.name = name; }}class Employee extends Person { private department: string; constructor(name: string, department: string) { super(name) this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; }}let howard = new Employee(\"Howard\", \"Sales\");console.log(howard.getElevatorPitch()); //由于Employee是派生自Person的，所以可以访问通过实例方法访问protected属性nameconsole.log(howard.name); // 错误 name是被保护的，只能在Person和subClasses中有权限访问 构造函数也可以被标记成 protected。 这意味着这个类不能在包含它的类外被实例化，但是能被继承。比如， 123456789101112131415161718192021class Person { protected name: string; protected constructor(theName: string) { this.name = theName; } //把构造函数设置成protected}// Employee 能够继承 Personclass Employee extends Person { private department: string; constructor(name: string, department: string) { super(name); this.department = department; } public getElevatorPitch() { return `Hello, my name is ${this.name} and I work in ${this.department}.`; }}let howard = new Employee(\"Howard\", \"Sales\");let john = new Person(\"John\"); // 错误: 'Person' 的构造函数是被保护的. 只读修饰符 readonly你可以使用 readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。 写法： 123class 类名 { readonly 属性名: 类型} 例子： 12345678910// 定义了一个章鱼classclass Octopus { readonly name: string; readonly numberOfLegs: number = 8; constructor (theName: string) { this.name = theName; }}let dad = new Octopus(\"Man with the 8 strong legs\");dad.name = \"Man with the 3-piece suit\"; // 错误! name 是只读的. 参数属性12345class 类名 { constructor (readonly 属性名: 类型) { }} 参数属性可以方便地让我们在一个地方定义并初始化一个成员。 下面的例子是对之前 Octopus类的修改版，使用了参数属性： 1234567class Octopus { readonly numberOfLegs: number = 8; constructor(readonly name: string) { } //设置一个只读参数name}let dad = new Octopus(\"Man with the 8 strong legs\");console.log(dad.name) //Man with the 8 strong legs 注意看我们是如何舍弃了 theName，仅在构造函数里使用 readonly name: string参数来创建和初始化 name成员。 我们把声明和赋值合并至一处 存取器 getters/settersTypeScript支持通过getters/setters来截取对对象成员的访问。 它能帮助你有效的控制对对象成员的访问。 首先，我们从一个没有使用存取器的例子开始。 123456789class Employee { fullName: string;}let employee = new Employee();employee.fullName = \"Bob Smith\"; //设置名字if (employee.fullName) { console.log(employee.fullName); //Bob Smith} 下面这个版本里，我们先检查用户密码是否正确，然后再允许其修改员工信息。 我们把对fullName的直接访问改成了可以检查密码的 set方法。 我们也加了一个 get方法，让上面的例子仍然可以工作。 1234567891011121314151617181920212223242526let passcode = \"secret passcode\";class Employee { private _fullName: string; get fullName(): string { return this._fullName; } set fullName(newName: string) { if (passcode &amp;&amp; passcode == \"secret passcode\") { this._fullName = newName; } else { console.log(\"Error: Unauthorized update of employee!\"); } }}let employee = new Employee();employee.fullName = \"Bob Smith\";if (employee.fullName) { alert(employee.fullName); // Bob Smith}// 如果我们在这里修改了 passcode变量，则不会弹出alert而是打印 Error: Unauthorized update of employee! 对于存取器有下面几点需要注意的： 首先，存取器要求你将编译器设置为输出ECMAScript 5或更高。 不支持降级到ECMAScript 3。 其次，只带有 get不带有 set的存取器自动被推断为 readonly。 这在从代码生成 .d.ts文件时是有帮助的，因为利用这个属性的用户会看到不允许够改变它的值。 静态属性 static到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 写法 123class 类名 { static 属性 = 属性值} 例子： 12345678910111213141516// 定义一个栅格的类class Grid { static origin = {x: 0, y: 0}; //定一个静态属性orign calculateDistanceFromOrigin(point: {x: number; y: number;}) { let xDist = (point.x - Grid.origin.x); //origin只能通过Gride访问，不能用this否则会报错 let yDist = (point.y - Grid.origin.y);//origin只能通过Gride访问，不能用this否则会报错 return Math.sqrt(xDist * xDist + yDist * yDist) / this.scale; //Math.sqrt() 函数返回一个数的平方根， } constructor (public scale: number) { }}let grid1 = new Grid(1.0); // 1x scalelet grid2 = new Grid(5.0); // 5x scaleconsole.log(grid1.calculateDistanceFromOrigin({x: 10, y: 10})); //14.142135623730951console.log(grid2.calculateDistanceFromOrigin({x: 10, y: 10})); //2.8284271247461903 在这个例子里，我们使用 static定义 origin，因为它是所有网格都会用到的属性。 每个实例想要访问这个属性的时候，都要在 origin前面加上类名。 如同在实例属性上使用 this.前缀来访问属性一样，这里我们使用 Grid.来访问静态属性。 抽象类 abstract抽象类做为其它派生类的基类使用。 它们一般不会直接被实例化。 不同于接口，抽象类可以包含成员的实现细节。 abstract关键字是用于定义抽象类和在抽象类内部定义抽象方法。 写法： 123abstract class 类名 { abstract 方法(参数类型):返回类型} 例子： 123456abstract class Animal { abstract makeSound(): void; //抽象方法，只描述不实现 必须在派生类中实现 move(): void { console.log('roaming the earch...'); }} 抽象类中的抽象方法不包含具体实现并且必须在派生类中实现。 抽象方法的语法与接口方法相似。 两者都是定义方法签名但不包含方法体。 然而，抽象方法必须包含 abstract关键字并且可以包含访问修饰符。 有几个规则: 抽象类可以直接赋值，允许创建一个对抽象类型的引用 不能创建一个抽象类的实例 允许对一个抽象子类进行实例化和赋值 在抽象子类中定义但在抽象类中没有声明的方法实例化后不能使用 抽象类中的abstract定义的方法必须在派生类中实现 在派生类的构造函数中必须调用 super() 123456789101112131415161718192021222324252627282930313233abstract class Department { constructor(public name: string) { } printName(): void { console.log('Department name: ' + this.name); } abstract printMeeting(): void; // 必须在派生类中实现}class AccountingDepartment extends Department { constructor() { super('Accounting and Auditing'); // 在派生类的构造函数中必须调用 super() } printMeeting(): void { console.log('The Accounting Department meets each Monday at 10am.'); } generateReports(): void { console.log('Generating accounting reports...'); }}let department: Department; // 允许创建一个对抽象类型的引用department = new Department(); // 错误: 不能创建一个抽象类的实例department = new AccountingDepartment(); // 允许对一个抽象子类进行实例化和赋值department.printName();department.printMeeting();department.generateReports(); // 错误: 方法在声明的抽象类中不存在 高级技巧构造函数当你在TypeScript里声明了一个类的时候，实际上同时声明了很多东西 类的实例的类型。 构造函数的值。 类具有 实例部分与 静态部分这两个部分 12345678910111213class Greeter { greeting: string; constructor(message: string) { this.greeting = message; } greet() { return \"Hello, \" + this.greeting; }}let greeter: Greeter; //Greeter类的实例的类型是 Greetergreeter = new Greeter(\"world\");console.log(greeter.greet()); //Hello, world 把类当做接口使用类定义会创建两个东西：类的实例类型和一个构造函数。 因为类可以创建出类型，所以你能够在允许使用接口的地方使用类。 12345678910class Point { x: number; y: number;}interface Point3d extends Point { z: number;}let point3d: Point3d = {x: 1, y: 2, z: 3}; 函数TypeScript为JavaScript函数添加了额外的功能，让我们可以更容易地使用。 函数类型为函数定义类型123456// 带函数名的函数function add(x: number, y: number): number { return x + y;}// 赋值的匿名函数let myAdd = function(x: number, y: number): number { return x + y; }; 我们可以给每个参数添加类型之后再为函数本身添加返回值类型。 TypeScript能够根据返回语句自动推断出返回值类型，因此我们通常省略它。 12// 不带返回值的写法let myAdd = function(x: number, y: number){ return x + y; }; 书写完整函数类型写法： 1(参数名: 类型, 参数名: 类型) =&gt; 返回值类型 例子： 123// 这个写法和上面为函数定义类型的写法效果实际上是一样的let myAdd: (x: number, y: number) =&gt; number = function(x: number, y: number): number { return x + y; }; 只要参数类型是匹配的，那么就认为它是有效的函数类型，而不在乎参数名是否正确。 123// baseValue -&gt; x increment-&gt; ylet myAdd: (baseValue: number, increment: number) =&gt; number = function(x: number, y: number): number { return x + y; }; 可选参数和默认参数传递给一个函数的参数个数必须与函数期望的参数个数一致。如果有的参数是可传可不传的则使用可选参数 可选参数写法： 123function (参数? : 类型) { //...} 例子： 12345678910function buildName(firstName: string, lastName?: string) { if (lastName) return firstName + \" \" + lastName; else return firstName;}let result1 = buildName(\"Bob\"); //oklet result2 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数多了let result3 = buildName(\"Bob\", \"Adams\"); // ok 默认值可以给函数参数设置默认值，就跟es6一样 写法： 123function (参数=值) { //...} 例子： 12345678function buildName(firstName: string, lastName = \"Smith\") { return firstName + \" \" + lastName;}let result1 = buildName(\"Bob\"); // ok, returns \"Bob Smith\"let result2 = buildName(\"Bob\", undefined);// ok, returns \"Bob Smith\"let result3 = buildName(\"Bob\", \"Adams\", \"Sr.\"); // error, 参数多了let result4 = buildName(\"Bob\", \"Adams\"); // ok 剩余参数123456function buildName(firstName: string, ...restOfName: string[]) { // 收集剩余参数到restOfName里 return firstName + \" \" + restOfName.join(\" \");}let employeeName = buildName(\"Joseph\", \"Samuel\", \"Lucas\", \"MacKinzie\"); //Joseph Samuel Lucas MacKinzie thisthis参数123456789101112131415161718192021222324252627282930// 定义一张牌的接口interface Card { suit: string; card: number;}// 定义一副牌的接口interface Deck { suits: string[]; cards: number[]; createCardPicker(this: Deck): () =&gt; Card;}// 设置一副牌let deck: Deck = { suits: [\"红桃\", \"黑桃\", \"梅花\", \"方块\"], //花色 cards: Array(52), //牌 // 注意:该函数现在显式地指定它的被调用方必须是Deck类型，指定this类型为Deck createCardPicker: function(this: Deck) { return () =&gt; { let pickedCard = Math.floor(Math.random() * 52); let pickedSuit = Math.floor(pickedCard / 13); return {suit: this.suits[pickedSuit], card: pickedCard % 13}; } }}let cardPicker = deck.createCardPicker();let pickedCard = cardPicker(); //抽到排alert(\"card: \" + pickedCard.card + \" of \" + pickedCard.suit); this参数在回调函数里当你将一个函数传递到某个库函数里稍后会被调用时，你可能会看到this报错 1234567891011121314interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void;}let uiElement:UIElementclass Handler { info: string; onClickBad(this: Handler, e: Event) { // oops, used this here. using this callback would crash at runtime this.info = e.message; }}let h = new Handler();uiElement.addClickListener(h.onClickBad); // error! 认为这个this的类型不匹配 修改 1234567891011121314interface UIElement { addClickListener(onclick: (this: void, e: Event) =&gt; void): void;}let uiElement:UIElementclass Handler { info: string; onClickBad = (e: Event) =&gt; { // 改为箭头函数即可，否则必须传入this为void类型 this.info = e.message; }}let h = new Handler();uiElement.addClickListener(h.onClickBad); 重载为同一个函数提供多个函数类型定义来进行函数重载。 编译器会根据这个列表去处理函数的调用。 举个例子：有个方法，传入数组，则从数组中抽一张牌。如果传入一个数字，则返回这个数字对应的花色和牌面数字。 下面这个例子没有使用重载 1234567891011121314151617181920212223let suits = [\"红桃\", \"黑桃\", \"梅花\", \"方块\"];function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; }}let myDeck = [{ suit: \"方块\", card: 2 }, { suit: \"黑桃\", card: 10 }, { suit: \"红桃\", card: 4 }];// 在调用方法的时候不会给有类型提示let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);// 在调用方法的时候不会给有类型提示let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 使用重载： 12345678910111213141516171819202122232425262728293031323334353637let suits = [\"红桃\", \"黑桃\", \"梅花\", \"方块\"];function pickCard(x: {suit: string; card: number; }[]): number; //重载，如果传入一个牌的对象，则返回值张牌在牌堆里的下标function pickCard(x: number): {suit: string; card: number; }; //重载，如果传入一个数字，则返回一张对应花色和数字的牌function pickCard(x): any { // Check to see if we're working with an object/array // if so, they gave us the deck and we'll pick the card if (typeof x == \"object\") { let pickedCard = Math.floor(Math.random() * x.length); return pickedCard; } // Otherwise just let them pick the card else if (typeof x == \"number\") { let pickedSuit = Math.floor(x / 13); return { suit: suits[pickedSuit], card: x % 13 }; }}let myDeck = [{ suit: \"方块\", card: 2 }, { suit: \"黑桃\", card: 10 }, { suit: \"红桃\", card: 4 }];// 在调用方法的时候会给有类型提示 /*function pickCard(x: { suit: string; card: number;}[]): number (+1 overload)*/let pickedCard1 = myDeck[pickCard(myDeck)];alert(\"card: \" + pickedCard1.card + \" of \" + pickedCard1.suit);// 在调用方法的时候会给有类型提示/*function pickCard(x: number): { suit: string; card: number;} (+1 overload)*/let pickedCard2 = pickCard(15);alert(\"card: \" + pickedCard2.card + \" of \" + pickedCard2.suit); 泛型在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 泛型之Hello World12345678// 假设我们想使用数字类型function identity(arg: number): number { return arg;}// 我们又想使用字符串类型function identity(arg: string): string { return arg;} 使用泛型一次搞定 1234// T代表一个类型function identity&lt;T&gt;(arg: T): T { return arg;} 使用泛型变量还看上面的例子。如果我们想同时打印出arg的长度。 1234function loggingIdentity&lt;T&gt;(arg: T): T { console.log(arg.length); // Error: T doesn't have .length return arg;} 现在假设我们想操作T类型的数组而不直接是T。由于我们操作的是数组，所以.length属性是应该存在的。 123456789function loggingIdentity&lt;T&gt;(arg: T[]): T[] { console.log(arg.length); // Array has a .length, so no more error return arg;}// 下面这个写法也可以function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; { console.log(arg.length); // Array has a .length, so no more error return arg;} 泛型类型写法： 12345interface 泛型接口名&lt;T&gt; { (参数名: T): T;}let 变量: 泛型接口&lt;类型&gt; = 方法// 传入的类型会替代定义的接口中的T 12345678910interface GenericIdentityFn&lt;T&gt; { (arg: T): T;}function identity&lt;T&gt;(arg: T): T { return arg;}// 使用接口定义方法let myIdentity: GenericIdentityFn&lt;number&gt; = identity; 除了泛型接口，我们还可以创建泛型类。 注意，无法创建泛型枚举和泛型命名空间。 泛型类泛型类看上去与泛型接口差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 12345class 类名&lt;T&gt; { //类内部根据需要引入T类型 属性名: T, 方法名: (参数名: T) =&gt; T} 例子： 12345678910class GenericNumber&lt;T&gt; { zeroValue: T; add: (x: T, y: T) =&gt; T;}let myGenericNumber = new GenericNumber&lt;number&gt;();myGenericNumber.zeroValue = 0;myGenericNumber.add = function(x, y) { return x + y; };console.log(myGenericNumber.add(2,3)) //5 泛型约束泛型约束就是给泛型增加额外的属性，使用这个泛型传入的值必须有对应的属性才能使用。简单的说就是约束传入的泛型。 写法： 12// T 拥有了接口约束的属性，同时也约束了传入的值必须有对应的属性&lt;T extends 接口&gt; 在 loggingIdentity例子中，我们想访问arg的length属性，但是编译器并不能证明每种类型都有length属性，所以就报错了。 1234function loggingIdentity&lt;T&gt;(arg: T): T { console.log(arg.length); // Error: T doesn't have .length return arg;} 使用泛型约束改写一下 12345678910111213interface Lengthwise { length: number;}function loggingIdentity&lt;T extends Lengthwise&gt;(arg: T): T { console.log(arg.length); // Now we know it has a .length property, so no more error return arg;}// 现在这个泛型函数被定义了约束，因此它不再是适用于任意类型：loggingIdentity(3); // Error, number doesn't have a .length property// 我们需要传入符合约束类型的值，必须包含必须的属性：loggingIdentity({length: 10, value: 3}); //ok 在泛型约束中使用类型参数你可以声明一个类型参数，且它被另一个类型参数所约束。 123456789// 传入的类型K被T约束function getProperty(obj: T, key: K) { return obj[key];}let x = { a: 1, b: 2, c: 3, d: 4 };getProperty(x, \"a\"); // okaygetProperty(x, \"m\"); // error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'. 在泛型里使用类类型在TypeScript使用泛型创建工厂函数时，需要引用构造函数的类类型。比如： 1234567891011121314151617// 定义一个方法，接受一个实例化之后类型为T的类作为参数，返回值是Tfunction create&lt;T&gt;(c: {new(): T; }): T { return new c();}interface Animal { name: string, move: (distance: number) =&gt; void}class Dog { name: 'dog' move(x) { console.log('move: ' + x + 'm') }}console.log(create&lt;Animal&gt;(Dog)) 一个更高级的例子，使用原型属性推断并约束构造函数与类实例的关系。 1234567891011121314151617181920212223242526class BeeKeeper { hasMask: boolean;}class ZooKeeper { nametag: string;}class Animal { numLegs: number;}class Bee extends Animal { keeper: BeeKeeper;}class Lion extends Animal { keeper: ZooKeeper;}function createInstance&lt;A extends Animal&gt;(c: new () =&gt; A): A { return new c();}createInstance(Lion).keeper.nametag; // 会报错nametag 不能是undefinedcreateInstance(Bee).keeper.hasMask; // 会报错 hasMask 不能是undefined","link":"/2020/05/29/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%BA%8C/"}],"tags":[{"name":"rough-notation","slug":"rough-notation","link":"/tags/rough-notation/"},{"name":"插件","slug":"插件","link":"/tags/%E6%8F%92%E4%BB%B6/"},{"name":"标记","slug":"标记","link":"/tags/%E6%A0%87%E8%AE%B0/"},{"name":"Typescript","slug":"Typescript","link":"/tags/Typescript/"}],"categories":[{"name":"插件","slug":"插件","link":"/categories/%E6%8F%92%E4%BB%B6/"},{"name":"Typescript","slug":"Typescript","link":"/categories/Typescript/"}]}