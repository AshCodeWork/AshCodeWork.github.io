<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Typescript系列课程(三) - Ash&#039;s Blog</title><meta description="本次主要讲的内容： 枚举 数字枚举 字符串枚举 异构枚举（Heterogeneous enums） 计算的和常量成员 联合枚举与枚举成员的类型 运行时的枚举 反向映射 const枚举   外部枚举   类型推论 基础 最佳通用类型 上下文类型   类型兼容性 介绍 开始 比较两个函数 函数参数双向协变 可选参数及剩余参数 函数重载   枚举 类 类的私有成员和受保护成员   泛型   高级类型 交"><meta property="og:type" content="blog"><meta property="og:title" content="Typescript系列课程(三)"><meta property="og:url" content="https://ashcodework.github.io/2020/06/08/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%89/"><meta property="og:site_name" content="Ash&#039;s Blog"><meta property="og:description" content="本次主要讲的内容： 枚举 数字枚举 字符串枚举 异构枚举（Heterogeneous enums） 计算的和常量成员 联合枚举与枚举成员的类型 运行时的枚举 反向映射 const枚举   外部枚举   类型推论 基础 最佳通用类型 上下文类型   类型兼容性 介绍 开始 比较两个函数 函数参数双向协变 可选参数及剩余参数 函数重载   枚举 类 类的私有成员和受保护成员   泛型   高级类型 交"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://ashcodework.github.io/img/og_image.png"><meta property="article:published_time" content="2020-06-08T10:31:50.000Z"><meta property="article:modified_time" content="2020-06-10T02:35:14.131Z"><meta property="article:author" content="Ash"><meta property="article:tag" content="Typescript"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://ashcodework.github.io/2020/06/08/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%89/"},"headline":"Ash's Blog","image":["https://ashcodework.github.io/img/og_image.png"],"datePublished":"2020-06-08T10:31:50.000Z","dateModified":"2020-06-10T02:35:14.131Z","author":{"@type":"Person","name":"Ash"},"description":"本次主要讲的内容： 枚举 数字枚举 字符串枚举 异构枚举（Heterogeneous enums） 计算的和常量成员 联合枚举与枚举成员的类型 运行时的枚举 反向映射 const枚举   外部枚举   类型推论 基础 最佳通用类型 上下文类型   类型兼容性 介绍 开始 比较两个函数 函数参数双向协变 可选参数及剩余参数 函数重载   枚举 类 类的私有成员和受保护成员   泛型   高级类型 交"}</script><link rel="canonical" href="https://ashcodework.github.io/2020/06/08/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%89/"><link rel="icon" href="/img/fish.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://cdn.bootcdn.net/ajax/libs/webfont/1.6.28/webfontloader.js"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/fish.svg" alt="Ash&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-06-08T10:31:50.000Z" title="2020-06-08T10:31:50.000Z">2020-06-08</time><span class="level-item"><a class="link-muted" href="/categories/Typescript/">Typescript</a></span><span class="level-item">37 minutes read (About 5607 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Typescript系列课程(三)</h1><div class="content"><h2 id="本次主要讲的内容："><a href="#本次主要讲的内容：" class="headerlink" title="本次主要讲的内容："></a>本次主要讲的内容：</h2><ul>
<li>枚举<ul>
<li>数字枚举</li>
<li>字符串枚举</li>
<li>异构枚举（Heterogeneous enums）</li>
<li>计算的和常量成员</li>
<li>联合枚举与枚举成员的类型</li>
<li>运行时的枚举<ul>
<li>反向映射</li>
<li>const枚举</li>
</ul>
</li>
<li>外部枚举</li>
</ul>
</li>
<li>类型推论<ul>
<li>基础</li>
<li>最佳通用类型</li>
<li>上下文类型</li>
</ul>
</li>
<li>类型兼容性<ul>
<li>介绍</li>
<li>开始</li>
<li>比较两个函数<ul>
<li>函数参数双向协变</li>
<li>可选参数及剩余参数</li>
<li>函数重载</li>
</ul>
</li>
<li>枚举</li>
<li>类<ul>
<li>类的私有成员和受保护成员</li>
</ul>
</li>
<li>泛型</li>
</ul>
</li>
<li>高级类型<ul>
<li>交叉类型（Intersection Types）</li>
<li>联合类型（Union Types）</li>
<li>类型保护与区分类型（Type Guards and Differentiating Types）<ul>
<li>用户自定义的类型保护</li>
<li>typeof类型保护</li>
<li>instanceof类型保护</li>
</ul>
</li>
<li>可以为null的类型<ul>
<li>可选参数和可选属性</li>
<li>类型保护和类型断言</li>
</ul>
</li>
<li>类型别名<ul>
<li>接口 vs. 类型别名</li>
</ul>
</li>
<li>字符串字面量类型</li>
<li>数字字面量类型</li>
<li>枚举成员类型</li>
<li>可辨识联合（Discriminated Unions）<ul>
<li>完整性检查</li>
</ul>
</li>
<li>多态的 this类型</li>
<li>索引类型（Index types）<ul>
<li>索引类型和字符串索引签名</li>
</ul>
</li>
<li>映射类型<ul>
<li>由映射类型进行推断</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>快速上手：<a href="https://www.tslang.cn/docs/handbook/typescript-in-5-minutes.html">点我跳转</a></p>
<p>Typescript文档地址：<a href="https://www.tslang.cn/docs/handbook/basic-types.html">点我跳转</a></p>
<p>练习地址：<a href="https://www.tslang.cn/play/index.html">点我跳转</a></p>
<a id="more"></a>

<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>使用枚举我们可以定义一些带名字的常量。 使用枚举可以清晰地表达意图或创建一组有区别的用例。</p>
<h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><p>数字枚举就是指枚举值都是数字。相当于定义一串key，key的值从上到下自增1。</p>
<p>写法： </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> 枚举类型 &#123;</span><br><span class="line">    枚举属性<span class="number">1</span>, <span class="comment">//默认是0 如果需要设置默认值：枚举属性1=1设置枚举属性值从1开始</span></span><br><span class="line">    枚举属性<span class="number">2</span>,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="number">1</span>, <span class="comment">//1</span></span><br><span class="line">    Down, <span class="comment">//2</span></span><br><span class="line">    Left, <span class="comment">//3</span></span><br><span class="line">    Right <span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上，我们定义了一个数字枚举， Up使用初始化为 1。 其余的成员会从 1开始自动增长。 换句话说， Direction.Up的值为 1， Down为 2， Left为 3， Right为 4。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up, <span class="comment">// 0</span></span><br><span class="line">    Down, <span class="comment">//1</span></span><br><span class="line">    Left, <span class="comment">//2</span></span><br><span class="line">    Right, <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在， Up的值为 0， Down的值为 1等等。 当我们不在乎成员的值的时候，这种自增长的行为是很有用处的，但是要注意每个枚举成员的值都是不同的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Values &#123;</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">respond</span>(<span class="params">recipient: <span class="built_in">string</span>, message: Values</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印传入的值</span></span><br><span class="line">    <span class="built_in">console</span>.log(recipient, message)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">respond(<span class="string">"Princess Caroline"</span>, Values.Yes) <span class="comment">//Princess Caroline 1</span></span><br></pre></td></tr></table></figure>

<h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><p>字符串是枚举值。定义的时候类似于定义对象。类似于数字枚举的写法，只不过传入的值为字符串。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Direction &#123;</span><br><span class="line">    Up = <span class="string">"UP"</span>,</span><br><span class="line">    Down = <span class="string">"DOWN"</span>,</span><br><span class="line">    Left = <span class="string">"LEFT"</span>,</span><br><span class="line">    Right = <span class="string">"RIGHT"</span>,</span><br><span class="line">&#125;</span><br><span class="line">alert(Direction.Up) <span class="comment">//UP</span></span><br><span class="line">alert(Direction.Down) <span class="comment">//DOWN</span></span><br><span class="line">alert(Direction.Left) <span class="comment">//LEFT</span></span><br><span class="line">alert(Direction.Right) <span class="comment">//RIGHT</span></span><br></pre></td></tr></table></figure>
<p>由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。 换句话说，如果你正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是很难读的 - 它并不能表达有用的信息（尽管 <a href="#反向映射">反向映射</a> 会有所帮助），字符串枚举允许你提供一个运行时有意义的并且可读的值，独立于枚举成员的名字。</p>
<h3 id="异构枚举（Heterogeneous-enums）"><a href="#异构枚举（Heterogeneous-enums）" class="headerlink" title="异构枚举（Heterogeneous enums）"></a>异构枚举（Heterogeneous enums）</h3><p>就是混合使用数字和字符串作为枚举值。不建议使用</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BooleanLikeHeterogeneousEnum &#123;</span><br><span class="line">    No = <span class="number">0</span>,</span><br><span class="line">    Yes = <span class="string">"YES"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="计算的和常量成员"><a href="#计算的和常量成员" class="headerlink" title="计算的和常量成员"></a>计算的和常量成员</h3><p>每个枚举成员都带有一个值，它可以是 常量或 计算出来的。 当满足如下条件时，枚举成员被当作是常量：</p>
<ul>
<li>它是枚举的第一个成员且没有初始化器，这种情况下它被赋予值 0<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123; X &#125;</span><br><span class="line"><span class="comment">// E.X 为常量0</span></span><br></pre></td></tr></table></figure></li>
<li>它不带有初始化器且它之前的枚举成员是一个 数字常量。 这种情况下，当前枚举成员的值为它上一个枚举成员的值加1<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E2 &#123;</span><br><span class="line">    A = <span class="number">1</span>, B, C</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// E.A 为常量1</span></span><br><span class="line"><span class="comment">// E.B 为常量2</span></span><br><span class="line"><span class="comment">// E.C 为常量3</span></span><br></pre></td></tr></table></figure></li>
<li>枚举成员使用<strong>常量枚举表达式</strong>初始化。 常数枚举表达式是TypeScript表达式的子集，它可以在编译阶段求值。 当一个表达式满足下面条件之一时，它就是一个常量枚举表达式：<ul>
<li>一个枚举表达式字面量（主要是字符串字面量或数字字面量)</li>
<li>一个对之前定义的常量枚举成员的引用（可以是在不同的枚举类型中定义的）</li>
<li>带括号的常量枚举表达式</li>
<li>一元运算符 <code>+</code>, <code>-</code>,<code>~</code>其中之一应用在了常量枚举表达式</li>
<li>常量枚举表达式做为二元运算符 <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&gt;&gt;&gt;</code>, <code>&amp;</code>, <code>|</code>, <code>^</code>的操作对象。 若常数枚举表达式求值后为 NaN或 Infinity，则会在编译阶段报错。</li>
</ul>
</li>
</ul>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E1 &#123;</span><br><span class="line">    B = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> E2 &#123;</span><br><span class="line">    A = <span class="number">1</span>, <span class="comment">//一个枚举表达式数字字面量</span></span><br><span class="line">    B = E1.B, <span class="comment">//一个对之前定义的常量E1枚举成员B的引用</span></span><br><span class="line">    D = <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">//结果：2 数字1向左移动一位</span></span><br><span class="line">    F = B | D <span class="comment">//常量枚举表达式做为二元运算符|</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(E2.A) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">console</span>.log(E2.B) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(E2.D) <span class="comment">//2</span></span><br><span class="line"><span class="built_in">console</span>.log(E2.F) <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>所有其它情况的枚举成员被当作是需要计算得出的值。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> FileAccess &#123;</span><br><span class="line">    <span class="comment">// 常量成员</span></span><br><span class="line">    None,</span><br><span class="line">    Read    = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</span><br><span class="line">    Write   = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</span><br><span class="line">    ReadWrite  = Read | Write,</span><br><span class="line">    <span class="comment">// 计算成员</span></span><br><span class="line">    G = <span class="string">"123"</span>.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="联合枚举与枚举成员的类型"><a href="#联合枚举与枚举成员的类型" class="headerlink" title="联合枚举与枚举成员的类型"></a>联合枚举与枚举成员的类型</h3><p>首先，枚举成员成为了类型。我们可以说某些成员 只能是枚举成员的值：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> ShapeKind &#123;</span><br><span class="line">    Circle,</span><br><span class="line">    Square,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Circle &#123;</span><br><span class="line">    kind: ShapeKind.Circle;</span><br><span class="line">    radius: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Square &#123;</span><br><span class="line">    kind: ShapeKind.Square;</span><br><span class="line">    sideLength: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c: Circle = &#123;</span><br><span class="line">    kind: ShapeKind.Square, <span class="comment">//kind报错：只能是Circle中的kind，也就是说必须是ShapeKind的枚举值ShapeKind.Circle。因为限定了变量c的类型，而类型接口中确定了kind属性的值</span></span><br><span class="line">    radius: <span class="number">100</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个变化是枚举类型本身变成了每个枚举成员的 联合（在高级类型中会讲）。 因此，TypeScript能够捕获在比较值的时候犯的愚蠢的错误。 例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    Foo,</span><br><span class="line">    Bar,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x: E</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x !== E.Foo || x !== E.Bar) &#123;</span><br><span class="line">        <span class="comment">//             ~~~~~~~~~~~</span></span><br><span class="line">        <span class="comment">// Error! Operator '!==' cannot be applied to types 'E.Foo' and 'E.Bar'.这个条件将永远返回true，因为这两个值涵盖了枚举E所有情况</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子里，我们先检查<code>x</code>是否不是 <code>E.Foo</code>。 如果通过了这个检查，然后 <code>||</code>会发生短路效果， <code>if</code>语句体里的内容会被执行。 然而，这个检查没有通过，那么 <code>x</code>则 只能为 <code>E.Foo</code>，因此没理由再去检查它是否为 <code>E.Bar</code></p>
<h3 id="运行时的枚举"><a href="#运行时的枚举" class="headerlink" title="运行时的枚举"></a>运行时的枚举</h3><p>枚举是在运行时真正存在的对象。它可以传递给函数。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> E &#123;</span><br><span class="line">    X, Y, Z</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">obj: &#123; X: <span class="built_in">number</span> &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> obj.X;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以，因为E有一个名为X的属性，它是一个数字。</span></span><br><span class="line">f(E);</span><br></pre></td></tr></table></figure>
<h4 id="反向映射"><a href="#反向映射" class="headerlink" title="反向映射"></a>反向映射</h4><p>可以用枚举返回的值映射会枚举的key</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> a = Enum.A;</span><br><span class="line"><span class="keyword">let</span> nameOfA = Enum[a]; <span class="comment">// "A"</span></span><br><span class="line"><span class="comment">// 生成的代码中，枚举类型被编译成一个对象，它包含了正向映射（ name -&gt; value）和反向映射（ value -&gt; name）。 引用枚举成员总会生成为对属性访问并且永远也不会内联代码。</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：不会为字符串枚举成员生成反向映射</strong></p>
<h4 id="const枚举"><a href="#const枚举" class="headerlink" title="const枚举"></a><code>const</code>枚举</h4><p>大多数情况下，枚举是十分有效的方案。 然而在某些情况下需求很严格。 为了避免在额外生成的代码上的开销和额外的非直接的对枚举成员的访问，我们可以使用 <code>const</code>枚举。 常量枚举通过在枚举上使用 <code>const</code>修饰符来定义。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B = A * <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量枚举只能使用常量枚举表达式，并且不同于常规的枚举，它们在编译阶段会被删除。简单说就是这种常量的枚举，在编译的时候会直接把枚举值放入对应使用的地方。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">enum</span> Directions &#123;</span><br><span class="line">    Up,</span><br><span class="line">    Down,</span><br><span class="line">    Left,</span><br><span class="line">    Right</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> directions = [Directions.Up, Directions.Down, Directions.Left, Directions.Right]</span><br></pre></td></tr></table></figure>
<p>编译后的代码为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> directions = [<span class="number">0</span> <span class="comment">/* Up */</span>, <span class="number">1</span> <span class="comment">/* Down */</span>, <span class="number">2</span> <span class="comment">/* Left */</span>, <span class="number">3</span> <span class="comment">/* Right */</span>];</span><br></pre></td></tr></table></figure>

<h3 id="外部枚举"><a href="#外部枚举" class="headerlink" title="外部枚举"></a>外部枚举</h3><p>外部枚举用来描述已经存在的枚举类型的形状。外部枚举和非外部枚举之间有一个重要的区别，在正常的枚举里，没有初始化方法的成员被当成常数成员。 对于非常数的外部枚举而言，没有初始化方法时被当做需要经过计算的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个枚举类型，常用在声明文件中</span></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">enum</span> Enum &#123;</span><br><span class="line">    A = <span class="number">1</span>,</span><br><span class="line">    B, <span class="comment">// 不带declare时会认为这个是常熟成员，此时它被认为是需要经过计算的</span></span><br><span class="line">    C = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h2><p>即，类型是在哪里如何被推断的。</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>TypeScript里，在有些没有明确指出类型的地方，类型推论会帮助提供类型。如下面的例子</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">3</span>; <span class="comment">//变量x的类型被推断为数字。 这种推断发生在初始化变量和成员，设置默认参数值和决定函数返回值时。</span></span><br></pre></td></tr></table></figure>

<h3 id="最佳通用类型"><a href="#最佳通用类型" class="headerlink" title="最佳通用类型"></a>最佳通用类型</h3><p>当需要从几个表达式中推断类型时候，会使用这些表达式的类型来推断出一个最合适的通用类型。例如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = [<span class="number">0</span>, <span class="number">1</span>, <span class="literal">null</span>];</span><br></pre></td></tr></table></figure>
<p>为了推断x的类型，我们必须考虑所有元素的类型。 这里有两种选择： <code>number</code>和<code>null</code>。 计算通用类型算法会考虑所有的候选类型，并给出一个兼容所有候选类型的类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo = [<span class="keyword">new</span> Rhino(), <span class="keyword">new</span> Elephant(), <span class="keyword">new</span> Snake()]; <span class="comment">//推断为 (Rhino | Elephant | Snake)[]</span></span><br></pre></td></tr></table></figure>
<p>这里，我们想让zoo被推断为Animal[]类型，但是这个数组里没有对象是Animal类型的，因此不能推断出这个结果。 为了更正，当候选类型不能使用的时候我们需要明确的指出类型：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> zoo: Animal[] = [<span class="keyword">new</span> Rhino(), <span class="keyword">new</span> Elephant(), <span class="keyword">new</span> Snake()]; <span class="comment">//Animal[]</span></span><br></pre></td></tr></table></figure>

<h3 id="上下文类型"><a href="#上下文类型" class="headerlink" title="上下文类型"></a>上下文类型</h3><p>TypeScript类型推论也可能按照相反的方向进行。 这被叫做“按上下文归类”。按上下文归类会发生在表达式的类型与所处的位置相关时。</p>
<h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p>我们使用了“兼容性”，它在语言规范里没有定义。 在TypeScript里，有两种兼容性：子类型和赋值。 它们的不同点在于，赋值扩展了子类型兼容性，增加了一些规则，允许和any来回赋值，以及enum和对应数字值之间的来回赋值。</p>
<p>语言里的不同地方分别使用了它们之中的机制。 实际上，类型兼容性是由赋值兼容性来控制的，即使在implements和extends语句也不例外。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在基于名义类型的类型系统中，数据类型的兼容性或等价性是通过明确的声明和/或类型的名称来决定的。这与结构性类型系统不同，它是基于类型的组成结构，且不要求明确地声明。用人话说就是typescript只在意你的类型组成的结果，不强制要求对class声明类类型。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p: Named;</span><br><span class="line"><span class="comment">// OK, 因为组成的结构类型中有name</span></span><br><span class="line">p = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure>

<h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>TypeScript结构化类型系统的基本规则是，如果x要兼容y，那么y至少具有与x相同的属性。比如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Named &#123;</span><br><span class="line">    name: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x: Named;</span><br><span class="line"><span class="comment">// y's inferred type is &#123; name: string; location: string; &#125;</span></span><br><span class="line"><span class="comment">// 如果这里直接给x赋值下面这个字面量对象会报x的类型错误</span></span><br><span class="line"><span class="keyword">let</span> y = &#123; name: <span class="string">'Alice'</span>, location: <span class="string">'Seattle'</span> &#125;;</span><br><span class="line"><span class="comment">// 关键点：这里要检查y是否能赋值给x，编译器检查x中的每个属性，看是否能在y中也找到对应属性。 在这个例子中，y必须包含名字是name的string类型成员。y满足条件，因此赋值正确。</span></span><br><span class="line">x = y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查函数参数时使用相同的规则：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">n: Named</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 注意，y有个额外的location属性，但这不会引发错误。 只有目标类型（这里是Named）的成员会被一一检查是否兼容。</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Hello, '</span> + n.name);</span><br><span class="line">&#125;</span><br><span class="line">greet(y); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h3 id="比较两个函数"><a href="#比较两个函数" class="headerlink" title="比较两个函数"></a>比较两个函数</h3><p>对来讲，在比较原始类型和对象类型的时候是比较容易理解的，问题是如何判断两个函数是兼容的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="function">(<span class="params">a: <span class="built_in">number</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="function">(<span class="params">b: <span class="built_in">number</span>, s: <span class="built_in">string</span></span>) =&gt;</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要查看x是否能赋值给y，首先看它们的参数列表。 x的每个参数必须能在y里找到对应类型的参数。 注意的是参数的名字相同与否无所谓，只*看它们的类型。 这里，x的每个参数在y中都能找到对应的参数，所以允许赋值。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">y = x; <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为y有个必需的第二个参数，但是x并没有，所以不允许赋值。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">x = y; <span class="comment">// Error</span></span><br></pre></td></tr></table></figure>
<p>类型系统强制源函数的返回值类型必须是目标函数返回值类型的子类型。</p>
<h4 id="函数参数双向协变"><a href="#函数参数双向协变" class="headerlink" title="函数参数双向协变"></a>函数参数双向协变</h4><p>当比较函数参数类型时，只有当源函数参数能够赋值给目标函数或者反过来时才能赋值成功。 这是不稳定的，因为调用者可能传入了一个具有更精确类型信息的函数，但是调用这个传入的函数的时候却使用了不是那么精确的类型信息。 实际上，这极少会发生错误，并且能够实现很多JavaScript里的常见模式。例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> EventType &#123; Mouse, Keyboard &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> Event &#123; timestamp: <span class="built_in">number</span>; &#125;</span><br><span class="line"><span class="keyword">interface</span> MouseEvent <span class="keyword">extends</span> Event &#123; X: <span class="built_in">number</span>; Y: <span class="built_in">number</span> &#125;</span><br><span class="line"><span class="keyword">interface</span> KeyEvent <span class="keyword">extends</span> Event &#123; keyCode: <span class="built_in">number</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenEvent</span>(<span class="params">eventType: EventType, handler: (n: Event) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">    <span class="keyword">let</span> target = <span class="built_in">document</span>.querySelector(<span class="string">'body'</span>)</span><br><span class="line">    target.addEventListener(<span class="string">'click'</span>, handler)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不健全，但有用并且常见</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: MouseEvent</span>) =&gt;</span> <span class="built_in">console</span>.log(e.x + <span class="string">','</span> + e.y));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入的是一个不准确的类型，但是使用的时候确是含有更多类型信息的类型。比如MouseEvent的类型信息是多于Event的</span></span><br><span class="line">listenEvent(EventType.Mouse, <span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">console</span>.log((&lt;MouseEvent&gt;e).x + <span class="string">','</span> + (&lt;MouseEvent&gt;e).y));</span><br><span class="line">listenEvent(EventType.Mouse, &lt;<span class="function">(<span class="params">e: Event</span>) =&gt;</span> <span class="built_in">void</span>&gt;<span class="function">(<span class="params">(<span class="params">e: MouseEvent</span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e.x + ',' + e.y</span>)</span>));</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// 需要的是<span class="params">Event</span>却传入的<span class="params">number</span></span></span><br><span class="line"><span class="function"><span class="params">listenEvent</span>(<span class="params">EventType.Mouse, (<span class="params">e: <span class="built_in">number</span></span>) =&gt; <span class="built_in">console</span>.log(<span class="params">e</span>)</span>); //<span class="params">Error</span></span></span><br></pre></td></tr></table></figure>
<h4 id="可选参数及剩余参数"><a href="#可选参数及剩余参数" class="headerlink" title="可选参数及剩余参数"></a>可选参数及剩余参数</h4><p>比较函数兼容性的时候，可选参数与必须参数是可互换的。 源类型上有额外的可选参数不是错误，目标类型的可选参数在源类型里没有对应的参数也不是错误。</p>
<p>剩余参数：当一个函数有剩余参数时，它被当做无限个可选参数。</p>
<p>可选参数：这对于类型系统来说是不稳定的，但从运行时的角度来看，可选参数一般来说是不强制的，因为对于大多数函数来说相当于传递了一些undefinded。</p>
<p>有一个好的例子，常见的函数接收一个回调函数并用对于程序员来说是可预知的参数但对类型系统来说是不确定的参数来调用：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeLater</span>(<span class="params">args: <span class="built_in">any</span>[], callback: (...args: <span class="built_in">any</span>[]) =&gt; <span class="built_in">void</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">/* ... Invoke callback with 'args' ... */</span></span><br><span class="line">    callback(args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不可靠 - invokeLater "might" provide any number of arguments</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">', '</span> + y)); <span class="comment">//1,2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让人困惑 (x and y are 事实上是需要的) and 非显示的</span></span><br><span class="line">invokeLater([<span class="number">1</span>, <span class="number">2</span>], <span class="function">(<span class="params">x?, y?</span>) =&gt;</span> <span class="built_in">console</span>.log(x + <span class="string">', '</span> + y)); <span class="comment">//1,2</span></span><br></pre></td></tr></table></figure>

<h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>对于有重载的函数，源函数的每个重载都要在目标函数上找到对应的函数签名。 这确保了目标函数可以在所有源函数可调用的地方调用。</p>
<h3 id="枚举-1"><a href="#枚举-1" class="headerlink" title="枚举"></a>枚举</h3><ul>
<li>枚举类型与数字类型兼容</li>
<li>数字类型与枚举类型兼容</li>
<li>不同枚举类型之间是不兼容的</li>
</ul>
<p>比如:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Status &#123; Ready, Waiting &#125;;</span><br><span class="line"><span class="keyword">enum</span> Color &#123; Red, Blue, Green &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _status = Status.Ready;</span><br><span class="line"><span class="keyword">let</span> a:<span class="built_in">number</span> = _status; <span class="comment">//数字类型与枚举类型兼容</span></span><br><span class="line">_status = Color.Green;  <span class="comment">// Error 不同枚举类型之间是不兼容的</span></span><br><span class="line">_status = <span class="number">3</span>; <span class="comment">//数字类型与枚举类型兼容</span></span><br></pre></td></tr></table></figure>

<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类与对象字面量和接口差不多，但有一点不同：类有静态部分和实例部分的类型。 比较两个类类型的对象时，只有实例的成员会被比较。 静态成员和构造函数不在比较的范围内。</p>
<p>TS中类的静态部分指的是这个类（函数）本身，实例部分指的是类实例化出来的对象</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Animal &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>; <span class="comment">//只检查feet</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span>, numFeet: <span class="built_in">number</span></span>) &#123; &#125; <span class="comment">//不检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Size &#123;</span><br><span class="line">    feet: <span class="built_in">number</span>; <span class="comment">//只检查feet</span></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">numFeet: <span class="built_in">number</span></span>) &#123; &#125; <span class="comment">//不检查</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> a: Animal;</span><br><span class="line"><span class="keyword">let</span> s: Size;</span><br><span class="line"></span><br><span class="line">a = s;  <span class="comment">// OK</span></span><br><span class="line">s = a;  <span class="comment">// OK</span></span><br></pre></td></tr></table></figure>

<h4 id="类的私有成员和受保护成员"><a href="#类的私有成员和受保护成员" class="headerlink" title="类的私有成员和受保护成员"></a>类的私有成员和受保护成员</h4><p>类的私有成员和受保护成员会影响兼容性。 当检查类实例的兼容时，如果目标类型包含一个私有成员，那么源类型必须包含来自同一个类的这个私有成员。 同样地，这条规则也适用于包含受保护成员实例的类型检查。 这允许子类赋值给父类，但是不能赋值给其它有同样类型的类。</p>
<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>因为TypeScript是结构性的类型系统，类型参数只影响使用其做为类型一部分的结果类型。比如</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Empty&lt;T&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: Empty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: Empty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y;  <span class="comment">// OK, because y matches structure of x</span></span><br></pre></td></tr></table></figure>
<p>上面代码里，x和y是兼容的，因为它们的结构使用类型参数时并没有什么不同。 把这个例子改变一下，增加一个成员，就能看出是如何工作的了：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> NotEmpty&lt;T&gt; &#123;</span><br><span class="line">    data: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> x: NotEmpty&lt;<span class="built_in">number</span>&gt;;</span><br><span class="line"><span class="keyword">let</span> y: NotEmpty&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"></span><br><span class="line">x = y;  <span class="comment">// Error, x 和 y不兼容了</span></span><br></pre></td></tr></table></figure>
<p>在这里，泛型类型在使用时就好比不是一个泛型类型。</p>
<h2 id="高级类型"><a href="#高级类型" class="headerlink" title="高级类型"></a>高级类型</h2><h3 id="交叉类型（Intersection-Types）"><a href="#交叉类型（Intersection-Types）" class="headerlink" title="交叉类型（Intersection Types）"></a>交叉类型（Intersection Types）</h3><p>交叉类型是将多个类型合并为一个类型。 这让我们可以把现有的多种类型叠加到一起成为一种类型，它包含了所需的所有类型的特性。</p>
<p>写法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型1 &amp; 类型2 &amp; 类型3</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定一个继承方法，可以将两个对象合并</span></span><br><span class="line"><span class="comment">// 这里定义了一个交叉类型 T &amp; U</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">first: T, second: U</span>): <span class="title">T</span> &amp; <span class="title">U</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = &lt;T &amp; U&gt;&#123;&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> first) &#123;</span><br><span class="line">        (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;first)[id];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> id <span class="keyword">in</span> second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!result.hasOwnProperty(id)) &#123;</span><br><span class="line">            (&lt;<span class="built_in">any</span>&gt;result)[id] = (&lt;<span class="built_in">any</span>&gt;second)[id];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Person &#123;</span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params"><span class="keyword">public</span> name: <span class="built_in">string</span></span>) &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Loggable &#123;</span><br><span class="line">    log(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> Loggable &#123;</span><br><span class="line">    log() &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jim = extend(<span class="keyword">new</span> Person(<span class="string">"Jim"</span>), <span class="keyword">new</span> ConsoleLogger());</span><br><span class="line"><span class="keyword">var</span> n = jim.name;</span><br><span class="line">jim.log();</span><br></pre></td></tr></table></figure>

<h3 id="联合类型（Union-Types）"><a href="#联合类型（Union-Types）" class="headerlink" title="联合类型（Union Types）"></a>联合类型（Union Types）</h3><p>联合类型与交叉类型类似，表示一串类型的或关系。可以是这一串类型中的任何一个。</p>
<p>写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型<span class="number">1</span> | 类型<span class="number">2</span> | 类型<span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在字符串的左面放一个 "padding".</span></span><br><span class="line"><span class="comment"> * If 'padding' is a string, 就把传入的'padding'放到左边.</span></span><br><span class="line"><span class="comment"> * If 'padding' is a number, 就把number*空格数放到文字左面.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">padLeft</span>(<span class="params">value: <span class="built_in">string</span>, padding: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"number"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Array</span>(padding + <span class="number">1</span>).join(<span class="string">" "</span>) + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> padding === <span class="string">"string"</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> padding + value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Expected string or number, got '<span class="subst">$&#123;padding&#125;</span>'.`</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">padLeft(<span class="string">"Hello world"</span>, <span class="number">4</span>); <span class="comment">// returns "    Hello world"</span></span><br><span class="line">padLeft(<span class="string">"Hello world"</span>, <span class="string">"  "</span>); <span class="comment">// returns "  Hello world"</span></span><br></pre></td></tr></table></figure>


<h3 id="类型保护与区分类型（Type-Guards-and-Differentiating-Types）"><a href="#类型保护与区分类型（Type-Guards-and-Differentiating-Types）" class="headerlink" title="类型保护与区分类型（Type Guards and Differentiating Types）"></a>类型保护与区分类型（Type Guards and Differentiating Types）</h3><p>我们像确切的知道哪一个类型怎么处理？</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个鸟的接口</span></span><br><span class="line"><span class="keyword">interface</span> Bird &#123;</span><br><span class="line">    fly();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个鱼的接口</span></span><br><span class="line"><span class="keyword">interface</span> Fish &#123;</span><br><span class="line">    swim();</span><br><span class="line">    layEggs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getSmallPet</span>(<span class="params"></span>): <span class="title">Fish</span> | <span class="title">Bird</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pet = getSmallPet();</span><br><span class="line">pet.layEggs(); <span class="comment">// okay</span></span><br><span class="line">pet.swim();    <span class="comment">// errors</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以使用断言处理</span></span><br><span class="line"><span class="keyword">if</span> ((&lt;Fish&gt;pet).swim) &#123;</span><br><span class="line">    (&lt;Fish&gt;pet).swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    (&lt;Bird&gt;pet).fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="用户自定义的类型保护"><a href="#用户自定义的类型保护" class="headerlink" title="用户自定义的类型保护"></a>用户自定义的类型保护</h4><p>假若我们一旦检查过类型，就能在之后的每个分支里清楚地知道 pet的类型的话就好了。我们可以使用<strong>类型谓词</strong>解决：</p>
<p>写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// parameterName必须是来自于当前函数签名里的一个参数名。</span></span><br><span class="line">parameterName is Type</span><br></pre></td></tr></table></figure>

<p>TypeScript里的 类型保护机制让它成为了现实。 类型保护就是一些表达式，它们会在运行时检查以确保在某个作用域里的类型。 要定义一个类型保护，我们只要简单地定义一个函数，它的返回值是一个 类型谓词：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isFish</span>(<span class="params">pet: Fish | Bird</span>): <span class="title">pet</span> <span class="title">is</span> <span class="title">Fish</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (&lt;Fish&gt;pet).swim !== <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子里， <code>pet is Fish</code>就是类型谓词。 谓词为<code>parameterName is Type</code>这种形式， <code>parameterName</code>必须是来自于当前函数签名里的一个参数名。</p>
<p>每当使用一些变量调用 <code>isFish</code>时，TypeScript会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'swim' 和 'fly' 调用都没有问题了</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isFish(pet)) &#123;</span><br><span class="line">    pet.swim();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    pet.fly();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意TypeScript不仅知道在 if分支里 pet是 Fish类型； 它还清楚在 else分支里，一定 不是 Fish类型，一定是 Bird类型。</p>
<h4 id="typeof类型保护"><a href="#typeof类型保护" class="headerlink" title="typeof类型保护"></a>typeof类型保护</h4><p>同js中使用typeof一样，进行类型判断。但是只能判断”number”， “string”， “boolean”或 “symbol”</p>
<p>写法：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> v === <span class="string">"typename"</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="keyword">typeof</span> v !== <span class="string">"typename"</span></span><br><span class="line"><span class="comment">// "typename"必须是 "number"， "string"， "boolean"或 "symbol"</span></span><br></pre></td></tr></table></figure>
<h4 id="instanceof类型保护"><a href="#instanceof类型保护" class="headerlink" title="instanceof类型保护"></a>instanceof类型保护</h4><h3 id="可以为null的类型"><a href="#可以为null的类型" class="headerlink" title="可以为null的类型"></a>可以为null的类型</h3><h4 id="可选参数和可选属性"><a href="#可选参数和可选属性" class="headerlink" title="可选参数和可选属性"></a>可选参数和可选属性</h4><h4 id="类型保护和类型断言"><a href="#类型保护和类型断言" class="headerlink" title="类型保护和类型断言"></a>类型保护和类型断言</h4><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><h4 id="接口-vs-类型别名"><a href="#接口-vs-类型别名" class="headerlink" title="接口 vs. 类型别名"></a>接口 vs. 类型别名</h4><h3 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h3><h3 id="数字字面量类型"><a href="#数字字面量类型" class="headerlink" title="数字字面量类型"></a>数字字面量类型</h3><h3 id="枚举成员类型"><a href="#枚举成员类型" class="headerlink" title="枚举成员类型"></a>枚举成员类型</h3><h3 id="可辨识联合（Discriminated-Unions）"><a href="#可辨识联合（Discriminated-Unions）" class="headerlink" title="可辨识联合（Discriminated Unions）"></a>可辨识联合（Discriminated Unions）</h3><h4 id="完整性检查"><a href="#完整性检查" class="headerlink" title="完整性检查"></a>完整性检查</h4><h3 id="多态的-this类型"><a href="#多态的-this类型" class="headerlink" title="多态的 this类型"></a>多态的 this类型</h3><h3 id="索引类型（Index-types）"><a href="#索引类型（Index-types）" class="headerlink" title="索引类型（Index types）"></a>索引类型（Index types）</h3><h4 id="索引类型和字符串索引签名"><a href="#索引类型和字符串索引签名" class="headerlink" title="索引类型和字符串索引签名"></a>索引类型和字符串索引签名</h4><h3 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h3><h4 id="由映射类型进行推断"><a href="#由映射类型进行推断" class="headerlink" title="由映射类型进行推断"></a>由映射类型进行推断</h4></div><div class="article-tags size-small mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Typescript/">Typescript</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/img/alipay.jpeg" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/img/wechat.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2020/06/03/%E6%A0%87%E8%AE%B0%E6%8F%92%E4%BB%B6roughnotation/"><span class="level-item">标记插件rough-notation</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><script src="https://utteranc.es/client.js" repo="AshCodeWork/ashcodework.github.io" issue-term="pathname" label="✨💬✨" theme="github-light" crossorigin="anonymous" async></script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.jpg" alt="Ash"></figure><p class="title is-size-4 is-block line-height-inherit">Ash</p><p class="is-size-6 is-block">web developer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>北京</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">5</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">2</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">4</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/AshCodeWork/ashcodework.github.io" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/AshCodeWork/ashcodework.github.io"><i class="fab fa-github"></i></a></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Typescript/"><span class="level-start"><span class="level-item">Typescript</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8F%92%E4%BB%B6/"><span class="level-start"><span class="level-item">插件</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-08T10:31:50.000Z">2020-06-08</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/08/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%89/">Typescript系列课程(三)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Typescript/">Typescript</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-03T13:49:10.000Z">2020-06-03</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/03/%E6%A0%87%E8%AE%B0%E6%8F%92%E4%BB%B6roughnotation/">标记插件rough-notation</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%8F%92%E4%BB%B6/">插件</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-29T17:28:25.000Z">2020-05-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/29/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%BA%8C/">Typescript系列课程(二)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Typescript/">Typescript</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-26T23:21:17.000Z">2020-05-26</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/26/Typescript%E7%B3%BB%E5%88%97%E8%AF%BE%E7%A8%8B-%E4%B8%80/">Typescript系列课程(一)</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Typescript/">Typescript</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-22T23:21:17.000Z">2020-05-22</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/22/hello-world/">Hello World</a></p><p class="is-uppercase"></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Typescript/"><span class="tag">Typescript</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rough-notation/"><span class="tag">rough-notation</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%8F%92%E4%BB%B6/"><span class="tag">插件</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%87%E8%AE%B0/"><span class="tag">标记</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="column-right-shadow is-hidden-widescreen is-sticky"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3 is-sticky"><div class="card widget" id="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="is-flex" href="#本次主要讲的内容："><span class="mr-2">1</span><span>本次主要讲的内容：</span></a></li><li><a class="is-flex" href="#枚举"><span class="mr-2">2</span><span>枚举</span></a><ul class="menu-list"><li><a class="is-flex" href="#数字枚举"><span class="mr-2">2.1</span><span>数字枚举</span></a></li><li><a class="is-flex" href="#字符串枚举"><span class="mr-2">2.2</span><span>字符串枚举</span></a></li><li><a class="is-flex" href="#异构枚举（Heterogeneous-enums）"><span class="mr-2">2.3</span><span>异构枚举（Heterogeneous enums）</span></a></li><li><a class="is-flex" href="#计算的和常量成员"><span class="mr-2">2.4</span><span>计算的和常量成员</span></a></li><li><a class="is-flex" href="#联合枚举与枚举成员的类型"><span class="mr-2">2.5</span><span>联合枚举与枚举成员的类型</span></a></li><li><a class="is-flex" href="#运行时的枚举"><span class="mr-2">2.6</span><span>运行时的枚举</span></a><ul class="menu-list"><li><a class="is-flex" href="#反向映射"><span class="mr-2">2.6.1</span><span>反向映射</span></a></li><li><a class="is-flex" href="#const枚举"><span class="mr-2">2.6.2</span><span>const枚举</span></a></li></ul></li><li><a class="is-flex" href="#外部枚举"><span class="mr-2">2.7</span><span>外部枚举</span></a></li></ul></li><li><a class="is-flex" href="#类型推论"><span class="mr-2">3</span><span>类型推论</span></a><ul class="menu-list"><li><a class="is-flex" href="#基础"><span class="mr-2">3.1</span><span>基础</span></a></li><li><a class="is-flex" href="#最佳通用类型"><span class="mr-2">3.2</span><span>最佳通用类型</span></a></li><li><a class="is-flex" href="#上下文类型"><span class="mr-2">3.3</span><span>上下文类型</span></a></li></ul></li><li><a class="is-flex" href="#类型兼容性"><span class="mr-2">4</span><span>类型兼容性</span></a><ul class="menu-list"><li><a class="is-flex" href="#介绍"><span class="mr-2">4.1</span><span>介绍</span></a></li><li><a class="is-flex" href="#开始"><span class="mr-2">4.2</span><span>开始</span></a></li><li><a class="is-flex" href="#比较两个函数"><span class="mr-2">4.3</span><span>比较两个函数</span></a><ul class="menu-list"><li><a class="is-flex" href="#函数参数双向协变"><span class="mr-2">4.3.1</span><span>函数参数双向协变</span></a></li><li><a class="is-flex" href="#可选参数及剩余参数"><span class="mr-2">4.3.2</span><span>可选参数及剩余参数</span></a></li><li><a class="is-flex" href="#函数重载"><span class="mr-2">4.3.3</span><span>函数重载</span></a></li></ul></li><li><a class="is-flex" href="#枚举-1"><span class="mr-2">4.4</span><span>枚举</span></a></li><li><a class="is-flex" href="#类"><span class="mr-2">4.5</span><span>类</span></a><ul class="menu-list"><li><a class="is-flex" href="#类的私有成员和受保护成员"><span class="mr-2">4.5.1</span><span>类的私有成员和受保护成员</span></a></li></ul></li><li><a class="is-flex" href="#泛型"><span class="mr-2">4.6</span><span>泛型</span></a></li></ul></li><li><a class="is-flex" href="#高级类型"><span class="mr-2">5</span><span>高级类型</span></a><ul class="menu-list"><li><a class="is-flex" href="#交叉类型（Intersection-Types）"><span class="mr-2">5.1</span><span>交叉类型（Intersection Types）</span></a></li><li><a class="is-flex" href="#联合类型（Union-Types）"><span class="mr-2">5.2</span><span>联合类型（Union Types）</span></a></li><li><a class="is-flex" href="#类型保护与区分类型（Type-Guards-and-Differentiating-Types）"><span class="mr-2">5.3</span><span>类型保护与区分类型（Type Guards and Differentiating Types）</span></a><ul class="menu-list"><li><a class="is-flex" href="#用户自定义的类型保护"><span class="mr-2">5.3.1</span><span>用户自定义的类型保护</span></a></li><li><a class="is-flex" href="#typeof类型保护"><span class="mr-2">5.3.2</span><span>typeof类型保护</span></a></li><li><a class="is-flex" href="#instanceof类型保护"><span class="mr-2">5.3.3</span><span>instanceof类型保护</span></a></li></ul></li><li><a class="is-flex" href="#可以为null的类型"><span class="mr-2">5.4</span><span>可以为null的类型</span></a><ul class="menu-list"><li><a class="is-flex" href="#可选参数和可选属性"><span class="mr-2">5.4.1</span><span>可选参数和可选属性</span></a></li><li><a class="is-flex" href="#类型保护和类型断言"><span class="mr-2">5.4.2</span><span>类型保护和类型断言</span></a></li></ul></li><li><a class="is-flex" href="#类型别名"><span class="mr-2">5.5</span><span>类型别名</span></a><ul class="menu-list"><li><a class="is-flex" href="#接口-vs-类型别名"><span class="mr-2">5.5.1</span><span>接口 vs. 类型别名</span></a></li></ul></li><li><a class="is-flex" href="#字符串字面量类型"><span class="mr-2">5.6</span><span>字符串字面量类型</span></a></li><li><a class="is-flex" href="#数字字面量类型"><span class="mr-2">5.7</span><span>数字字面量类型</span></a></li><li><a class="is-flex" href="#枚举成员类型"><span class="mr-2">5.8</span><span>枚举成员类型</span></a></li><li><a class="is-flex" href="#可辨识联合（Discriminated-Unions）"><span class="mr-2">5.9</span><span>可辨识联合（Discriminated Unions）</span></a><ul class="menu-list"><li><a class="is-flex" href="#完整性检查"><span class="mr-2">5.9.1</span><span>完整性检查</span></a></li></ul></li><li><a class="is-flex" href="#多态的-this类型"><span class="mr-2">5.10</span><span>多态的 this类型</span></a></li><li><a class="is-flex" href="#索引类型（Index-types）"><span class="mr-2">5.11</span><span>索引类型（Index types）</span></a><ul class="menu-list"><li><a class="is-flex" href="#索引类型和字符串索引签名"><span class="mr-2">5.11.1</span><span>索引类型和字符串索引签名</span></a></li></ul></li><li><a class="is-flex" href="#映射类型"><span class="mr-2">5.12</span><span>映射类型</span></a><ul class="menu-list"><li><a class="is-flex" href="#由映射类型进行推断"><span class="mr-2">5.12.1</span><span>由映射类型进行推断</span></a></li></ul></li></ul></li></ul></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/fish.svg" alt="Ash&#039;s Blog" height="28"></a><p class="size-small"><span>&copy; 2020 Ash</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://ashcodework.github.io',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>